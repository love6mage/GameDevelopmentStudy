# Collision and Rigid Body Dynamics

## Do You Want Physics in Your Game

- `collision detection system` 碰撞检测系统，游戏引擎的核心组件之一，确保物体不会相互穿过，通常与物理引擎（`physics engine`）紧密集成
- `Rigid body dynamics simulation` 刚体动态模拟。物理学领域是巨大的，现在大多数游戏引擎称呼为“物理学（`physics`）”的东西描述为刚体动态模拟更准确

### Things You Can Do with a Physics System

- 检测动态物体和静态世界几何之间的碰撞
- 模拟受重力和其他力影响的自由刚体
- `Spring-mass systems` 弹簧质点系统
- 可破坏的建筑物和结构
- 射线和形状（用于确定视线、子弹撞击等）
- `Trigger volumes` 触发体（决定物体何时进入、离开或位于游戏中的预定义区域）
- 复杂的机器（起重机、移动平台拼图等）
- 陷阱（如崩落的巨石）
- 具有逼真悬架的可驾驶车辆
- 布娃娃角色死亡
- `Powered rag doll` 传统动画和布娃娃物理的现实融合
- 悬垂的道具（水壶、项链、剑），半真实的头发，衣服的动作
- 布料模拟
- 水面模拟和浮力
- 音频传播
- ...
- 物理模拟可以运行时执行或作为生成动画片段的离线预处理步骤执行，例如 Maya 中有大量可用的物理插件

### Is Physics Fun

- `Simulations (Sims)` 模拟游戏的主要目标是重现真实的体验，例如飞行模拟器、GT 赛车、纳斯卡赛车系列游戏，刚体动力学系统提供的真实性非常适合这类游戏
- `Physics Puzzle Games` 物理益智游戏的主要想法是让用户玩动态模拟玩具，这种游戏的核心机制几乎完全依赖于物理学，例如 Bridge Builder、不可思议的机器、奇妙装置、蜡笔物理学
- `Sandbox Games` 沙盒游戏中，可能根本没有目标，或者可能存在大量可选目标，玩家的主要目标通常是“乱搞”和探索游戏世界中的物体可以做什么，例如侠盗猎车手 5、孢子、小小大星球 2、撕纸小邮差、我的世界。沙盒游戏可以很好地使用真实动态模拟，尤其是如果许多乐趣来源于游戏世界中物体间的真实或半真实交互。有时动态模拟可能通过各种方式微调以实现正确的感觉或增加乐趣因素，如比真实大的爆炸，比正常更强或更弱的重力
- `Goal-Based and Story-Driven Games` 基于目标的游戏有规则和玩家必须完成以推动进度的特定目标，故事驱动的游戏中讲故事至关重要。将物理系统集成到这类游戏中十分棘手。我们通常会放弃控制以换取逼真的模拟，这种失控会抑制玩家完成目标和游戏讲述故事的能力。开发者必须小心应用物理并采取措施以各种方式控制模拟的行为，以确保它不阻碍游戏玩法。为玩家提供一个摆脱困境的方法通常也是个好主意，例如光晕系列游戏玩家可以按 X 翻转颠倒的车辆

### Impact of Physics on a Game

- `Design Impacts` 设计影响
  - `Predictability` 可预测性。将物理模拟行为从动画行为中分离的固有的混乱和多变性是不可预测性的一个来源。如果某些事情总是以具体的方式发生，通常最好使用动画，而不是尝试强迫动态模拟来产生可靠运动
  - `Tuning and control` 调整和控制。物理定律（准确建模时）是固定的，游戏中可以调整重力值或刚体恢复系数，但是调整物理参数的结果通常是间接的，难以可视化。调整力让角色向所需方向移动比调整角色行走动画难得多
  - `Emergent behaviors` 应急行为。有时物理会在游戏中引入意想不到的功能，例如军团要塞中的火箭发射器跳跃技巧，光晕中的高空爆炸疣猪，心理战中的飞行的“冲浪板”
- `Engineering Impacts` 工程影响
  - `Tools pipeline` 工具流水线。良好的碰撞/物理流水线需要时间来构建和维护
  - `User interface` 用户接口。玩家如何控制物理物体，如 Trespasser 中使用虚拟手臂握住他们，半条命 2 中使用“重力枪”
  - `Collision detection` 碰撞检测。旨在动态模拟中使用的碰撞模型比非物理驱动的可能要更详细和更精心的构造
  - `AI` 人工智能。在存在物理模拟物体的情况下，可能无法预测路径，引擎可能需要处理可以移动或爆炸的动态覆盖点
  - `Misbehaved objects` 行为不端的物体。物体由动态模拟驱动时，可能由意想不到的方式相互反弹或抖动严重。可能需要应用碰撞过滤允许物体稍微互相穿透，需要建立机制确保物体稳定并适当进入睡眠状态
  - `Rag doll physics` 布娃娃物理。布娃娃需要大量微调且通常受到在模拟中不稳定的影响。动画可能驱动角色身体的部分穿透到其他碰撞体，当角色变为布娃娃时，这些互相穿透可能造成巨大的不稳定性。需要采取措施避免这个问题
  - `Graphics` 物理学。物理驱动的运动可能影响可渲染物体的包围体（否则它们将是静态的或更可预测的），可破坏建筑和物体的存在可能使某些预计算照明和阴影方法无效
  - `Networking and multiplayer` 网络和多人游戏。不影响游戏玩法的物理效果可以独立地只在每个客户端机器上模拟，影响游戏玩法的物理效果必须在服务器上模拟并准确复制到所有客户端
  - `Record and playback` 记录和回放。记录游戏并在以后播放它，作为调试和测试辅助手段十分有用，还可以作为一个有趣的游戏功能。这个功能要求每个引擎系统以确定的方式运行
- `Art Impacts` 美术影响
  - `Additional tool and workflow complexity` 额外的工具和工作流复杂度。装配具有质量、摩擦力、约束和其他用于动态模拟的属性的物体的需求使得美术部门的工作也更加困难
  - `More-complex content` 更复杂的内容。可能需要为物体提供多个视觉相同但具有不同碰撞和动态配置的版本，例如一个原始版本和一个可破坏版本
  - `Loss of control` 失控。物理驱动物体的不可预测性使控制场景的美术构成更加困难
- `Other Impacts` 其他影响
  - `Interdisciplinary impacts` 跨学科影响。在游戏中引入动态模拟需要工程、美术、音频和设计之间的紧密合作
  - `Production impacts` 生产影响。物理学会增加项目的开发成本、技术和组织复杂度以及风险

## Collision/Physics Middleware

### I-Collide, SWIFT, V-Collide and RAPID

- `I-Collide` 是 UNC 开发的开源碰撞检测库，它可以检测凸（`convex`）体间的交叉。I-Collide 已经被更快、功能更丰富的库 `SWIFT` 取代。UNC 还开发了可以处理复杂非凸形状的碰撞检测库 `V-Collide` 和 `RAPID`。这些库无法正确地开箱即用，但是它们可以为构建功能齐全的游戏碰撞检测引擎提供良好的基础

### ODE

- `ODE` 代表“开放动力学引擎（`Open Dynamics Engine`）”，是开源的碰撞和刚体动力学 SDK。其功能集与商业产品 Havok 相近。好处是免费和完整代码可用

### Bullet

- `Bullet` 是开源的碰撞检测和物理库，用于游戏和电影行业。它的碰撞引擎集成到了它的动态模拟中，但是提供了钩子使碰撞系统可以单独使用或集成到其他物理引擎中。它支持连续碰撞检测（`continuous collision detection / CCD`），也称为碰撞时间（`time of impact / TOI`）碰撞检测，当模拟包含小且快速移动的物体时非常有帮助

### TrueAxis

- 碰撞/物理 SDK，可以免费用于非商业用途

### PhysX

- `PhysX` 最开始是由 Ageia 制作和发行的称为 Novodex 的库，作为推出他们的专用物理协处理器的战略的一部分，后被 NVIDIA 购买和改良，使它能使用 NVIDIA 的 GPU 作为协处理器运行。Ageia 和 NVIDIA 的部分营销策略是完全免费提供 SDK 的 CPU 版本，以推动物理协处理器市场向前发展。开发者可以付费获取完全源代码和根据需要定制库的能力。PhysX 现在与 APEX 绑定，APEX 是 NVIDIA 的可扩展多平台动态框架。PhysX / APEX 可用于 Windows、Linux、Mac、Android、Xbox 360、PlayStation 3、Xbox One、PlayStation 4 和 Wii

### Havok

- `Havok` 是商业物理 SDK 的黄金标准，提供了最丰富的功能集之一，并在所有支持平台上具有出色的性能特征。Havok 由一个核心碰撞/物理引擎和一些可选附加产品，包括车辆物理系统、用于建模可破坏环境的系统、一个直接集成到 Havok 布娃娃物理系统的功能齐全的动画 SDK 组成。可用于 Xbox 360、PlayStation 3、Xbox One、PlayStation 4、PlayStation Vita、Wii、Wii U、Windows 8、Android、Apple Mac 和 iOS

### Physics Abstraction Layer (PAL)

- 开源库，允许开发者在一个项目上使用多个物理 SDK，为 PhysX（Novodex）、Newton、ODE、OpenTissue、Tokamak、TrueAxis 和其他一些 SDK 提供钩子

### Digital Molecular Matter (DMM)

- Pixelux Entertainment S.A. 制作的一个独特物理引擎，使用有限元方法来模拟可变形体和易碎物体的动力学。该引擎同时具有离线和运行时组件。可以在 LucasArts 的星球大战：原力释放中看到

## The Collision Detection System

- 游戏引擎的碰撞检测系统主要目的是决定游戏世界中的任何物体是否接触。每个逻辑物体表示为一个或多个几何形状，如球形、盒形、胶囊形等，碰撞系统决定任何这些形状在任何给定时间点是否相交，所以碰撞检测系统本质上是一种美化的几何交叉测试仪
- 碰撞系统可用于多种目的：避免屏幕上不真实的视觉异常，例如物体间的相互穿透；导弹击中目标时让导弹爆炸；玩家角色通过漂浮的健康包时给予角色健康提升；等等
- 刚体动态模拟通常是碰撞系统的要求最高的客户端，用碰撞系统模拟物理逼真的行为如弹跳、滚动、滑动、静止等；但是，即使是没有物理系统的游戏仍然可以大量使用碰撞检测引擎

### Collidable Entities

- 想要游戏中的特定逻辑物体有能力与其他物体碰撞，需要给它提供一个碰撞表示（`collision representation`），描述物体的形状和在游戏世界中的位置和方向。这是一个独特的数据结构，不同于物体的游戏表示（`gameplay representation`，定义物体在游戏中的角色和行为）和视觉表示（`visual representation`，可能是三角形网格实例、细分曲面、粒子效果或其他视觉表示）
- 从检测交叉的角度看，我们通常更喜欢几何和数学简单的形状。理想情况下，只有当简单表示证明不足以在游戏中实现期望的行为时才采用更复杂的形状
- Havok 使用术语 `collidable` 描述一个可以参与碰撞检测的独特的刚体，每个 collidable 表示为 C++ 类 `hkpCollidable` 的一个实例；PhysX 称它的刚体为 `actors`，将它们表示为类 `NxActor` 的实例。两个库中可碰撞实体都包含两个基本信息：形状和变换。需要变换信息有三个原因
  - 一个形状必须变换以在自然空间中正确定位和定向
  - 移动任何复杂形状时，如果我们不得不单独移动它的所有特性（顶点、平面等），成本很高，而使用变换可以低成本移动形状，不管它的特性有多复杂
  - 描述形状的信息占用大量内存，所以允许多个可碰撞实体共享一个形状描述是有益的
- 游戏中任何特定物体可能根本没有 collidable（不需要碰撞检测）、有一个 collidable（物体是一个简单刚体）或有多个 collidable（例如每个表示铰接机器人臂的一个刚性组件）

### The Collision/Physics World

- 碰撞系统通常通过单例数据结构碰撞世界（`collision world`）跟踪它所有的可碰撞实体，碰撞世界是明确设计用于碰撞检测系统的游戏世界的一个完整表示。Havok 中碰撞世界是类 `hkpWorld` 的一个实例，PhysX 中是 `NxScene`，ODE 中是 `dSpace`
- 碰撞世界通常是表示游戏中所有可碰撞形状的几何体的层次结构的根
- 将所有碰撞信息维护在一个私有数据结构中与试图将碰撞信息保存到游戏物体本身相比有多个优点
  - 碰撞世界只需要包含潜在可能相互碰撞的物体的 Collidable，避免迭代任何不相关数据结构
  - 这个设计允许碰撞数据以可能最高效的方式组织，例如可以利用缓存一致性最大化性能
  - 碰撞世界是一种有效的封装机制，从可理解性、可维护性、可测试性、可重用性的角度看通常是一个优点
- `The Physics World` 刚体动态系统通常与碰撞系统紧密集成，通常与碰撞系统共享“世界”数据结构，模拟中的每个刚体通常与碰撞系统中的一个 Collidable 关联。这种设计在物理引擎中很常见，因为物理系统需要频繁和详细的碰撞查询。通常由物理系统实际驱动碰撞系统的操作，每个模拟时间步骤指示它执行碰撞测试最少一次，或有时多次，因此碰撞世界通常称为碰撞/物理世界（`collision/physics world`）或有时仅称为物理世界（`physics world`）
- 动态模拟中每个动态刚体通常与碰撞系统中的一个 Collidable 关联，尽管不是所有 Collidable 都需要动态刚体。例如 Havok 中刚体表示为 `hkpRigidBody` 的实例，每个刚体有一个指向一个 `hkpCollidable` 的指针；PhysX 中 Collidable 和刚体的概念混合在一起，`NxActor` 类用于这两个目的，尽管刚体的物理属性单独保存在 `NxBodyDesc` 实例中。两个 SDK 中都可以告诉刚体它的位置和方向在空间中固定，意味着他们将被动态模拟省略，只作为一个 Collidable
- 尽管紧密集成，大多数物理 SDK 确实至少做过尝试将碰撞库与刚体动态模拟分开。这允许碰撞系统作为独立库使用，对于不需要物理但需要检测碰撞的游戏十分重要；也意味着游戏工作室理论上可以完全替换一个物理 SDK 的碰撞系统而不需要重写动态模拟，这实际上比听起来要难

### Shape Concepts

- 丰富的数学理论是日常形状概念的基础。可以将形状想象为由边界描述的一个空间区域，有明确的内部和外部。二维空间中，形状有区域，边界由曲线或多条边（多边形）定义；三维空间中，形状有体积，边界由曲面或多边形（多面体）定义
- 有些游戏物体，例如地形、河或薄壁，可能最好用表面表示，三维空间中，表面是二维几何体，有前和后，但是没有内部或外部。许多碰撞 SDK 提供对表面基元的支持，扩展形状的概念以包括封闭体积和开放表面
- 碰撞库通常允许表面通过可选的挤出参数给定体积，这样的参数定义表面的“厚度”，有助于减少小且快速移动的物体与无限薄的表面间错过碰撞的发生
- 碰撞系统通常打包接触信息到一个数据结构内，例如 Havok 将接触作为 `hkContactPoint` 类的实例返回。接触信息通常包含一个分离向量（`separating vector`），沿这个向量移动物体可以使其有效地从碰撞中移开；通常还包含接触的两个 Collidable 的信息：哪些形状相交，甚至这些形状的哪些特性接触。系统可能还返回额外的信息，例如投射到分离法线上的物体速度
- `Convexity` 凸和非凸形状是一个重要分别，通常凸形状间比凹形状间的碰撞检测更简单且计算密度更低

### Collision Primitives

- `Spheres` 球，最简单的三维体，最高效的碰撞元，由一个中心点和一个半径表示，可以方便装到一个四元浮点向量中
- `Capsules` 胶囊，一个圆柱和两个半球端盖组成，通常由两个点和一个半径表示，比圆柱和盒高效
- `Axis-Aligned Bounding Boxes (AABB)` 轴对齐包围盒，每个面都与坐标轴平行，由两个点定义：一个包含盒沿每个主轴的最小坐标，一个包含最大坐标。优点是盒间的交叉测试十分高效，缺点是物体旋转后需要重计算包围盒，且包围盒可能与物体形状相似度极差
- `Oriented Bounding Boxes (OBB)` 方向包围盒，可以相对于其坐标系旋转，通常由三个长度（半宽、半深、半高）和一个变换（定位和定向盒中心点）表示
- `Discrete Oriented Polytopes (DOP)` 离散定向多面体，是 AABB 和 OBB 的更一般情况，是凸多面体。AABB 和 OBB 都是 6-DOP。构造 DOP 通常的方法是先构造一个 OBB，然后使用额外的平面将边或角倾斜 45 度
- `Arbitrary Convex Volumes` 任意凸体，大多数碰撞引擎允许 3D 美术师在像 Maya 这样的包中构造任意凸体，离线工具分析凸体的三角形，确保他们形成一个凸多面体，然后这些三角形被转化为平面集，表示为 k 个平面方程，或 k 个点和 k 个法线向量
- `Polygon Soup / Poly Soup` 多边形集合，一些碰撞系统也支持完全任意的非凸形状，称为多边形集合，常用于建模复杂的静态几何，如地形和建筑
  - 多边形集合的碰撞检测是最耗时的，必须测试每个三角形，并正确处理相邻三角形共享边的假交点，所以大多数游戏尝试限制多边形集合的使用，使其不参与动态模拟
  - 多边形集合不需要表示体积，即表示一个开放表面。可以使用三角形绕序提供表面的前后信息或体的内外信息；也可以伪造开放表面的内外部，例如用多边形集合表示地势时，可以判断任意表面的前面总是指向远离地球的地方
- `Compound Shapes` 复合形状，对于非凸物体的建模，通常可以是多边形集合的更有效的替代，多个凸体通常可以胜过单个多边形集合。一些碰撞系统可以在测试碰撞时利用复合形状作为一个整体的凸包围体，在 Havok 中称为中期碰撞检测（`midphase collision detection`），复合形状的凸包围体测试如果不相交，则系统根本不需要测试子形状的碰撞

### Collision Testing and Analytical Geometry

- 碰撞系统可以使用解析几何（`analytical geometry`，三维体和面的数学表示）在计算上检测形状间的相交
- `Point versus Sphere` 判断点是否在球中，可以简单比较点到球心的距离与球半径
- `Sphere versus Sphere` 判断两球是否相交，可以简单比较两球心的距离与两球半径的和
  - 为避免计算距离的平方根操作，可以将距离的比较转化为距离的平方的比较
- `The Separating Axis Theorem` 分离轴定理，被大多数碰撞系统大量使用。它指出，如果可以找到一个轴，使得两个凸形状在这个轴上的投影不重叠，则这两个形状不相交
  - 二维空间中，如果可以找到一条线，使得形状 A 完全在线的一边，形状 B 完全在线的另一边，则 A 和 B 不相交，这条线称为分界线（`separating line`），分界线总是与分离轴垂直
  - 某些类型的形状具有使潜在分离轴明显的属性，可以将两个形状轮流投影在这些潜在分离轴上，然后检查投影区间是否重叠
- `AABB versus AABB` AABB 间的相交可以简单应用分离轴定理判断
- `Detecting Convex Collisions: The GJK Algorithm` 检测凸形状碰撞的 GJK 算法
  - `Minkowski difference` Minkowski 差，形状 B 内每个点与形状 A 内每个点的差的集合。当两个形状都是凸形状时，这个集合中包含原点，当且仅当两个形状相交。两个凸形状的 Minkowski 差本身也是一个凸形状
  - `Simplex` 单形，是一组点，一个点的单形是点，两个点的单形是线段，三个点的单形是三角形，四个点的单形是四面体（`tetrahedron`）
  - GJK 算法利用了 Minkowski 差，但是只关心差的凸包（`convex hull`），而不是内部所有点，GJK 的主要过程就是尝试去找位于凸包上且包含原点的四面体，找得到则形状相交，否则不相交。GJK 是迭代算法，开始于 Minkowski 差凸包上任意一点，即一个点的单形，尝试构建可能包含原点的更高阶单形。在每个迭代中，查看当前已有的单形，判断原点位于单形的哪个方向，在该方向上找到支持顶点即离原点最近的凸包上的点，将该点加入当前单形来创建更高阶的单形。如果新创建的单形包含原点，则算法结束，两形状相交；如果无法找到支持顶点，则两形状不相交
- `Other Shape-Shape Combinations` 形状间的绑定数量非常大，对于 $N$ 个形状类型，需要按对测试的数量为 $O(N^2)$，这是碰撞引擎通常限制基元数量的一个原因，也是 GJK 算法流行的原因：它一举处理所有凸形状类型间的碰撞检测。
  - 给定任意两个形状，需要选择合适的碰撞测试函数。许多碰撞引擎使用双重调度（`double dispatch`）方法，通常使用二维函数查找表实现，查找关键字是要测试的物体的形状类型；也可以实现为安排基于物体 A 的虚函数调用基于物体 B 的虚函数
- `Detecting Collisions between Moving Bodies` 游戏中的动作通常在离散的时间步骤中模拟，当物体小且高速移动时，每个时间步骤间覆盖的距离远大于它的尺寸。碰撞世界两次连续快照中快速移动物体的图像中间会有一个间隙，如果其他物体刚好在这个间隙中，会完全错过碰撞，这个问题称为“子弹穿过纸张（`bullet through paper`）”问题或者“隧道（`tunneling`）”问题
  - `Swept Shapes` 可以使用扫掠形状避免隧道问题。扫掠形状是一个形状从一个点到另一个点的运动形成的新形状，例如一个扫掠球是一个胶囊形状。可以测试物体从前一个快照的位置和方向移动到当前快照的位置和方向形成的扫掠形状，而不是测试碰撞世界的静态快照。这相当于在快照间线性插值可碰撞物的运动，但是线性插值不适用于沿曲线运动或自旋转的物体，这两种情况下物体运动的扫掠形状可能是非凸形状
  - `Continuous Collision Detection (CCD)` 连续碰撞检测，CCD 的目的是找到给定时间间隔内两个移动物体间的最早影响时间（`time of impact / TOI`）。CCD 算法本质上通常是迭代的，对于每个可碰撞物，维护它前一个时间步骤和当前时间的位置和方向，用于独立地线性插值位置和旋转，产生可碰撞物在前一个和当前时间步骤间任意时间点的变换的近似，然后在运动路径上查找最早 TOI。通常使用很多查找算法，包括 Brian Mirtich 的 conservative advancement 方法

### Performance Optimizations

- 判断两个形状相交需要的计算很耗时，且大多数游戏世界包含大量物体，当物体数量增加时所需的碰撞测试数急剧增长
- `Temporal Coherency / frame-to-frame coherency` 利用时间一致性：当可碰撞物以合理速度移动时，它们的位置和方向在时间步骤间通常十分相似。通常可以通过跨多个时间步骤缓存结果来避免每帧重新计算某些类型的信息
- `Spatial Partitioning` 空间划分，将空间分为一些小区域，如果一对可碰撞物不出现在同一区域，则不需要为它们执行具体的碰撞测试，显著减少所需的碰撞测试数。可以使用各种层次划分模式，例如八叉树、BSP、kd-tree、球树等，树的一个分支上的物体不能与其它兄弟分支上的物体碰撞
- `Broad Phase, Midphase and Narrow Phase` Havok 使用三层方法修剪需要测试碰撞的可碰撞物集合
  - `Broad Phase` 粗略阶段，使用总的 AABB 测试判断可碰撞物是否潜在相交
    - `The Sweep and Prune Algorithm` 扫描和修剪算法，按三个主轴对可碰撞物的 AABB 的最小和最大坐标进行排序，然后遍历排序列表检查重叠的 AABB。该算法可以使用帧间一致性将 $O(n\log{n})$ 的排序操作减少到 $O(n)$ 的预期执行时间
  - `Midphase` 中间阶段，测试复合类型的粗略包围体
  - `Narrow Phase` 细测阶段，测试各可碰撞物的基元

### Collision Queries

- 碰撞查询，碰撞检测系统回答关于游戏世界中碰撞体的假想问题，例如子弹从玩家的武器向给定方向飞行，将击中的第一个目标是什么？一辆车可否从 A 点移动到 B 点而不会在路上撞到任何东西？找到角色给定半径内的所有敌方物体
- 最常用的查询为碰撞投射（`collision cast`），有时仅称为投射（`cast`，`trace` 和 `probe` 的同义词），一个投射确定一个假想物体放进碰撞世界并沿一条射线或线段移动会击中的物体。投射与常规碰撞检测操作不同的是投射物体不是真的在碰撞世界中，它不会影响世界中其他物体
- `Ray Casting` 最简单的碰撞投射类型是射线投射（`ray cast`），这里实际有点用词不当，我们真正投射的是一个有向线段，有开始端点 $p_0$ 和结束端点 $p_1$，表示为

  $$
  p(t)=p_0+td,\ t\in[0,1]
  $$

  - 这条线段与碰撞世界中的可碰撞物进行测试，如果它们相交，则返回接触点。大多数碰撞检测系统可以返回最早接触点，即离 $p_0$ 最近的接触点，对应 $t$ 的最小值；有些系统可以返回与线段相交的所有可碰撞物的完整列表。返回的信息通常包括 $t$ 的值，击中的可碰撞物的 ID，接触点表面法线和其他击中的形状或表面相关的属性
  - 射线投射在游戏中大量使用于武器系统（判断子弹命中）、玩家机制（判断角色脚下是否存在坚实地面）、AI 系统（视线检测、定位、移动查询等）、车辆系统（定位并将车辆的轮胎卡在地形上）等
- `Shape Casting` 其他常用查询包括查询假想凸形状沿有向线段在击中坚实物体之前能移动多远，沿有向线段投射一个形状称为形状投射（`shape cast`），Havok 中称为线性投射（`linear cast`），当投射体是球时也称为球投射（`sphere cast`）。形状投射通常描述为开始点 $p_0$，要移动的距离 $\overrightarrow{d}$，投射形状的类型、尺寸和方向
  - 投射一个凸形状有两种情况需要考虑
    - 投射形状已经与至少一个可碰撞物相互穿透或接触，阻止它从开始点移开。该情况下碰撞系统通常直接上报投射形状与可碰撞物间的接触点（在投射形状内部或表面）
    - 投射形状与其他可碰撞物不相交，可以沿其路径自由移动一个非零距离。该情况下投射形状通常只击中一个可碰撞物，但是也可能同时击中多个可碰撞物，或与非凸形状的多边形集合的多个部分同时接触（但是接触点总是在投射形状表面）
  - 与射线投射相同，一些 API 返回投射形状经历的最早接触点，其他 API 则允许形状继续沿假想路径移动并返回它经历的所有接触点。返回信息通常包括 $t$ 的值，击中的可碰撞物 ID 和 接触点，接触点表面法线和其他击中的形状或表面相关的属性。当返回信息是列表且未按 $t$ 排序时，可能需要我们自己进行排序
  - 形状投射在游戏中十分有用。球投射可以用于判断虚拟相机是否与游戏世界中的物体碰撞，球或胶囊投射通用于实现角色运动，例如角色在不均匀地形上向前滑动，可以在运动方向上投射一个位于角色脚之间的球或胶囊，然后通过二次投射将脚调高或调低，保持其与地面接触
- `Phantoms` 幻影，Havok 支持的特殊可碰撞物类型，与距离向量 $\overrightarrow{d}$ 为零的形状投射十分相似，且返回数据本质上与零距离形状投射格式相同。与形状投射不同，幻影在碰撞世界中是持久的，这意味着可以完全利用时间一致性优化；与常规可碰撞物不同，幻影对碰撞世界中其他可碰撞物（包括其他幻影）不可见，不参与动态模拟，不影响其他可碰撞物
  - 用于判断哪些可碰撞物位于游戏世界中一些特殊体内，例如得到玩家角色给定半径内的所有敌人的列表
- `Other Types of Queries` 一些碰撞引擎支持其他类型的查询，例如 Havok 支持最近点（`closest point`）查询，用于查找碰撞世界中与给定可碰撞物最近的其他可碰撞物上的点的集合

### Collision Filtering

- 大多数碰撞引擎允许根据游戏特定标准接受或拒绝可碰撞物间的接触，这称为碰撞过滤（`collision filtering`）
- `Collision Masking and Layers` 碰撞掩蔽和分层，将物体分类，然后查询表来判断特定类物体是否允许与其他类物体碰撞，例如 Havok 中一个可碰撞物可以是一个碰撞层的成员，每个碰撞层维护一个 32 位掩码，表示该层物体是否可以与其它层的物体碰撞
- `Collision Callbacks` 碰撞回调，让碰撞库在检测到碰撞时调用一个回调函数，让回调函数基于合适的标准决定接受还是拒绝这个碰撞，例如接触点首次添加到世界后，Havok 回调 `contactPointAdded()`，如果回调函数判断接触点合法，再回调 `contactPointConfirmed()`
- `Game-Specific Collision Materials` 许多游戏实现了与渲染引擎中使用的材质系统（`material system`）在很多方面类似的碰撞形状分类机制，一些游戏团队使用碰撞材质（`collision material`）描述这种分类。主要思想是关联每个可碰撞物表面和一组定义表面如何从物理和碰撞角度来表现的属性，可以包括声音和粒子效果，物理属性如恢复系数、摩擦系数，碰撞过滤信息，等等

## Rigid Body Dynamics

- 游戏物理系统几乎只关注称为经典刚体动力学（`classical rigid body dynamics`）的一个子学科
  - `Classical (Newtonian) mechanics` 经典（牛顿）力学，物体的模拟遵循牛顿运动定律。物体足够大，不存在量子效应；物体足够慢，不存在相对论效应
  - `Rigid bodies` 刚体，所有模拟的物体都是坚固、不可变形的
- 物理引擎确保刚体的运动遵循各种约束（`constraints`），最常见的约束是刚体不能相互穿透，其他可能包括铰接、棱柱关节（滑块）、球关节、轮子、布娃娃等
- 物理系统通常共享碰撞世界数据结构，作为时间步更新程序驱动碰撞检测算法执行
- 物理引擎中的刚体不同于从游戏角度看组成虚拟世界的逻辑物体。为了通过物理模拟驱动游戏物体的位置和方向，我们每帧向物理引擎查询每个刚体的变换，通过某些方式将它应用于对应游戏物体的变换。由其他引擎系统（如动画系统或角色控制系统）决定的游戏物体的运动也可以反过来驱动物理世界中刚体的位置和旋转

### Some Foundations

- `Units` 单位，大多数刚体动态模拟在 MKS 单位系统上运行。MKS 系统中距离以米（`meter`）为单位，质量以千克（`kilogram`）为单位，时间以秒（`second`）为单位。配置物理系统使用其他单位时要确保模拟中的所有内容都是一致的
- `Separability of Linear and Angular Dynamics` 线性和角动力学的可分离性
  - `unconstrained rigid body` 不受约束的刚体，可以沿三个笛卡尔轴自由平移，还可以关于这三个轴自由旋转，我们称这样的刚体有六个自由度（`degrees of freedom / DOF`）
  - 不受约束的刚体的运动可以分离为两个单独的组成部分
    - `Linear dynamics` 线性动力学，对体的运动的描述，忽略所有旋转效果
    - `Angular dynamics` 角动力学，对体的旋转运动的描述
- `Center of Mass` 质量中心，本质上是刚体所有可能方向的平衡点，或者说，刚体质量绕质量中心在所有方向上均匀分布
  - 对于均匀密度的体，其质量中心位于体的形心（`centroid`）
  - 对于不均匀密度的体，可以将其分为 N 个加权的小部分计算质量中心
- `Linear Dynamics` 线性动力学，刚体位置可以完全表示为其质量中心的位置
- `Linear Velocity and Acceleration` 线性速度和加速度，定义体的质量中心移动的速度、加速度和方向

  $$
  v(t)=\frac{\mathrm{d}r(t)}{\mathrm{d}t}=\dot r(t)
  $$
  $$
  a(t)=\frac{\mathrm{d}v(t)}{\mathrm{d}t}=\dot v(t) \\
  =\frac{\mathrm{d}^2r(t)}{\mathrm{d}t^2}=\ddot r(t)
  $$
- `Force and Momentum` 力和动量。力定义为导致具有质量的物体加速或减速的作用，有大小和方向，用向量表示，通常表示为 $F$。
  - $N$ 个力作用于一个刚体时，体的线性运动的净效应

    $$
    F_{net}=\sum_{i=1}^NF_i
    $$

  - 牛顿第二定律

    $$
    F(t)=ma(t)=m\ddot{r}(t)
    $$

  - 体的线性速度和质量的乘积称为线性动量（`linear momentum`）

    $$
    p(t)=mv(t)
    $$

  - 当体的质量不恒定，例如火箭的燃料逐渐耗尽转换为能量时，力的正确公式

    $$
    F(t)=\frac{\mathrm{d}p(t)}{\mathrm{d}t}=\frac{\mathrm{d}(m(t)v(t))}{\mathrm{d}t}
    $$

### Solving the Equations of Motion

- 刚体动力学的核心问题是给定一组已知的作用于体的力，解决体的运动
- `Force as a Function` 力可以是不变的，也可以是关于时间、体的位置、体的速度或其他量的一个函数

  $$
  F(t,r(t),v(t),\dots)=ma(t)=m\ddot{r}(t)
  $$

  - 例如，弹簧施加的力与它拉伸后离自然静止位置的距离成正比，机械粘滞阻尼器（缓冲器）施加的力与缓冲器活塞的速度成正比
- `Ordinary Differential Equations / ODE` 常微分方程，通常是一个等式，包含一个自变量的函数和该函数的各阶导数，如果自变量是时间，函数是 $x(t)$，则一个 ODE 的形式如下

  $$
  \frac{\mathrm{d}^nx}{\mathrm{d}t^n}=f(t,x(t),
  \frac{\mathrm{d}x}{\mathrm{d}t}),
  \frac{\mathrm{d}^2x}{\mathrm{d}t^2},\dots,
  \frac{\mathrm{d}^{n-1}x}{\mathrm{d}t^{n-1}})
  $$

  - 力是关于时间、位置和速度的的函数，如下式，明显是一个 ODE，我们希望解决这个 ODE 来得到 $v(t)$ 和 $r(t)$

    $$
    \ddot{r}(t)=\frac{1}{m}F(t,r(t),\dot{r}(t))
    $$
- `Analytical Solutions` 极少的情况下，运动的微分方程可以通过分析求解，这意味着可以找到一个简单的封闭函数描述体在所有可能时间 $t$ 的位置。然而这在游戏物理中几乎不可能，因为某些微分方程的封闭解决方案是未知的，而且游戏是交互式模拟，通常无法预测物体在某个时间所受的力。这个经验法则当然也有例外，例如求解封闭表达式来决定抛射物要击中预定目标的必须的发射速度很常见

### Numerical Integration

- 数值积分，使用时间分步（`time-stepped`）方式来解决微分方程。时间步的持续时间通常大致不变，用 $\Delta{t}$ 表示，给定体在当前时间 $t_1$ 的位置和速度，以及力关于时间、位置和速度的函数，我们期望找到体在下个时间步 $t_2=t_1+\Delta{t}$ 的位置和速度，即给定 $r(t_1)$，$v(t_1)$ 和 $F(t,r,v)$ 求 $r(t_2)$ 和 $v(t_2)$
- `Explicit Euler` 显示欧拉方法，ODE 最简单的数值解法之一，常被新游戏程序员采用
  - $v(t)=\dot{r}(t)$ 的近似显示欧拉解为
    $$
    r(t_2)=r(t_1)+v(t_1)\Delta{t}
    $$
  - $a(t)=\frac{F_{net}}{m}=\dot{v}(t)$ 的近似显示欧拉解为
    $$
    v(t_2)=v(t_1)+\frac{F_{net}}{m}\Delta{t}
    $$
  - `Interpretations of Explicit Euler` 显示欧拉的解释
    - 假设了物体的速度在下个时间步不变
    - 可以解释为两个有限差分的商，即 $\frac{\mathrm{d}r}{\mathrm{d}t}=\frac{\Delta{r}}{\Delta{t}}$
    - 当时间步中速度大致不变或 $\Delta{t}$ 趋向于零时运作得很好
- `Properties of Numerical Methods` 常微分方程的数值解法有三个重要且相互关联的属性
  - `Convergence` 收敛，随着时间步 $\Delta{t}$ 趋向于 $0$，近似解是否越来越靠近真实解
  - `Order` 阶数，我们称一个数值方法为 $n$ 阶，如果它的误差项为 $O(\Delta{t}^{n+1})$。误差项可以用 ODE 的数值解法方程减去 ODE 的精确解法的无限泰勒级数展开得到。下式误差项为 $O(\Delta{t}^2)$

    $$
    r(t_2)=r(t_1)+\dot{r}(t_1)\Delta{t}+O(\Delta{t}^2)
    $$

  - `Stability` 数值解法是否随着时间推移而稳定下来。如果数值方法给系统添加能量，物体的速度最终会“爆炸”，系统将变得不稳定；如果数值方法趋于从系统中移除能量，将具有整体阻尼效果，系统将稳定
- `Alternatives to Explicit Euler` 显示欧拉误差大、稳定性差，一般不用于通用动态模拟，解决 ODE 的各种其他数值方法如下
  - `Backward Euler` 一阶方法
  - `Midpoint Euler` 二阶方法
  - `Runge-Kutta` Runge-Kutta 方法家族，四阶的 Runge-Kutta 方法（RK4）特别受欢迎
- `Verlet Integration` 最常用的 ODE 数值解法，有两个变体
  - `Regular Verlet` 由两个泰勒级数展开相加得到

    $$
    r(t_1+\Delta{t})=r(t_1)+\dot{r}(t_1)\Delta{t}+\frac{1}{2}\ddot{r}(t_1)\Delta{t}^2+\frac{1}{6}r^{(3)}(t_1)\Delta{t}^3+O(\Delta{t}^4)
    $$
    $$
    r(t_1-\Delta{t})=r(t_1)-\dot{r}(t_1)\Delta{t}+\frac{1}{2}\ddot{r}(t_1)\Delta{t}^2-\frac{1}{6}r^{(3)}(t_1)\Delta{t}^3+O(\Delta{t}^4)
    $$
    $$
    r(t_1+\Delta{t})=2r(t_1)-r(t_1-\Delta{t})+a(t_1)\Delta{t}^2+O(\Delta{t}^4)
    $$

    - 速度可是使用下式模拟，误差较大

      $$
      v(t_1+\Delta{t})=\frac{r(t_1+\Delta{t})-r(t_1)}{\Delta{t}}+O(\Delta{t})
      $$

  - `Velocity Verlet` 更常用，需要四步处理

    $$
    r(t_1+\Delta{t})=r(t_1)+v(t_1)\Delta{t}+\frac{1}{2}a(t_1)\Delta{t}^2 \tag{1}
    $$
    $$
    v(t_1+\frac{1}{2}\Delta{t})=v(t_1)+\frac{1}{2}a(t_1)\Delta{t} \tag{2}
    $$
    $$
    a(t_1+\Delta{t})=a(t_2)=\frac{1}{m}F(t_2,r(t_2),v(t_2)) \tag{3}
    $$
    $$
    v(t_1+\Delta{t})=v(t_1+\frac{1}{2}\Delta{t})+\frac{1}{2}a(t_1+\Delta{t})\Delta{t} \tag{4}
    $$

    - 第 (3) 步中，力函数与下个时间步的位置和速度相关，$r(t_2)$ 已经在第 (1) 步中计算，所以如果力与速度无关，则我们已经得到了所有需要的信息。如果力与速度相关，我们必须得到下个时间步的近似速度，也许使用显示欧拉方法

### Angular Dynamics in Two Dimensions

- `Angular dynamics` 对施加的力响应的体旋转运动的研究称为角动力学。二维中刚体可以视为一块薄薄的材料，这样的体在一些物理文章中称为平面层（`plane lamina`），它的所有线性运动发生在 xy 平面中，所有的旋转运动都关于 z 轴
- `Orientation` 二维刚体的方向使用一个角度 $\theta$ 完全描述，这个角度相对于商定的零旋转，单位为弧度（$rad$），例如一辆赛车正面朝自然空间 x 轴正方向时可以定义 $\theta=0$。这个角度是关于时间的函数，所以表示为 $\theta(t)$
- `Angular Speed and Acceleration` 角速度和加速度，角速度测量体的旋转角度随时间变化的速率，单位为弧度每秒（$rad/s$），表示为 $w(t)$；加速度测量角速度的变化速率，单位为弧度每秒平方（$rad/s^2$），表示为 $\alpha(t)$

  Angular | Linear
  :- | :-
  $w(t)=\frac{\mathrm{d}\theta(t)}{\mathrm{d}t}=\dot{\theta}(t)$ | $v(t)=\frac{\mathrm{d}r(t)}{\mathrm{d}t}=\dot{r}(t)$
  $\alpha(t)=\frac{\mathrm{d}w(t)}{\mathrm{d}t}=\dot{w}(t)=\ddot{\theta}(t)$ | $a(t)=\frac{\mathrm{d}v(t)}{\mathrm{d}t}=\dot{v}(t)=\ddot{r}(t)$

  - 这边速度表示为 speed 而不是 velocity，因为二维中角速度是标量
- `Moment of Inertia` 惯性矩，是质量的旋转当量，质量描述改变一个点质量的线性速度的难易程度，而惯性矩描述改变一个刚体关于特定轴的旋转速度的难易程度，质量分布越集中在旋转轴附近，难度越小，惯性矩越小。通常表示为 $I$，在二维中是一个标量
- `Torque` 扭矩。如果力的作用线穿过体的质量中心，则这个力只产生线性运动，否则除了线性运动外这个力还引入一个称为扭矩的旋转力。假设从质量中心到力 $F$ 的作用点的向量可以表示为 $r$，则 $F$ 产生的扭矩 $N$ 为 $N=r\times F$，如下图

  ![Torque](Images/Torque.PNG)

  - 多个扭矩可以像多个力一样简单相加，表示为 $N_{net}$
  - 在二维中扭矩总是平行于 z 轴，所以二维扭矩可以表示为标量 $N_z$。力与线性加速度和质量有关，同样地，扭矩与角加速度和惯性矩有关

    Angular | Linear
    :- | :-
    $N_z(t)=I\alpha(t)=I\dot{w}(t)=I\ddot{\theta}(t)$ | $F(t)=ma(t)=m\dot{v}(T)=m\ddot{r}(t)$

- `Solving the Angular Equations of Motion in Two Dimensions` 解决二维角运动方程可以使用应用于线性动力学问题中的相同的数值积分技术。我们期望解决的 ODE 如下

  Angular | Linear
  :- | :-
  $N_{net}(t)=I\dot{w}(t)$ | $F_{net}(t)=m\dot{v}(T)$
  $w(t)=\dot{\theta}(t)$ | $v(t)=\dot{r}(t)$

### Angular Dynamics in Three Dimensions

- `The Inertia Tensor` 惯性张量。三维中，刚体的旋转质量表示为 $3\times 3$ 矩阵，这个矩阵称为惯性张量，通常用 $I$ 表示

  $$
  I=\begin{bmatrix}
  I_{xx} & I_{xy} & I_{xz} \\
  I_{yx} & I_{yy} & I_{yz} \\
  I_{zx} & I_{zy} & I_{zz}
  \end{bmatrix}
  $$

  - 这个矩阵的对角线元素为体关于它三个主轴的惯性矩，非对角线元素称为惯性积（`products of inertia`）。当体关于三个主轴分别对称时惯性积为零，当惯性积非零时常常产生物理上现实但是普通玩家可能认为是“错误”的不直观的动作，所以游戏引擎中惯性张量通常简化为三元向量 $\begin{bmatrix}I_{xx} & I_{yy} & I_{zz}\end{bmatrix}$
- `Orientation in Three Dimensions` 三维中体的方向可以表示为三个欧拉角 $\begin{bmatrix}\theta_x & \theta_y & \theta_z\end{bmatrix}$，每个角分别表示体关于一个主轴的旋转，但是欧拉角存在万向节锁定问题且数学上不好处理，所以三维中体的方向通常表示为 $3\times 3$ 矩阵 $R$ 或四元数 $q$。商定的零旋转可以是任意方向，但是在游戏所有组件间要一致
- `Angular Velocity and Momentum in Three Dimensions` 三维角速度和角动量，角速度不守恒（`not conserved`），动量守恒，所以我们在动态模拟中将角动量作为主要量，角速度作为次要量，而不是像线性速度一样作为主要量，通常在模拟的时间步中只在决定角动量值后才决定角速度值
  - 角速度向量 $\mathbf{w}(t)$ 可以看作定义旋转轴的单位向量 $\mathbf{u}$ 用体关于旋转轴的二维角速度 $w_u=\dot{\theta}_u$ 缩放

    $$
    \mathbf{w}(t)=w_u(t)\mathbf{u}=\dot{\theta}_u(t)\mathbf{u}
    $$
  
  - $\mathbf{w}(t)$ 不守恒，因为旋转轴可能会不停变化方向

    ![AngularVelocityNotConserved](Images/AngularVelocityNotConserved.PNG)

  - 角动量是线性动量的旋转当量

    Angular 3D | Linear
    :- | :-
    $\mathbf{L}(t)=\mathbf{Iw}(t)$ | $\mathbf{p}(t)=m\mathbf{v}(t)$

- `Torque in Three Dimensions` 三维中扭矩的计算同样满足 $N=r\times F$，但总是用角动量表示，因为角速度不守恒

  $$
  N=I\alpha(t)=I\frac{\mathrm{d}w(t)}{\mathrm{d}t}=\frac{\mathrm{d}}{\mathrm{d}t}(Iw(t))=\frac{\mathrm{d}L(t)}{\mathrm{d}t}
  $$

- `Solving the Equations of Angular Motion in Three Dimensions` 解决三维角运动方程不能使用与线性运动和二维角运动完全相同的方法，因为三维角运动常微分方程有以下两个不同点
  - 要求解角动量而不是角速度
  - 给定三元向量形式的角速度，无法直接求解四元数形式的方向，需要额外的处理
- 可以构造角速度四元数 $w=\begin{bmatrix}w_x & w_y & w_z & 0\end{bmatrix}$，得到 ODE 如下

  Angular 3D | Linear
  :- | :-
  $N_{net}=\dot{L}(t)$ | $F_{net}=\dot{p}(t)$
  $\mathbf{w}(t)=I^{-1}L(t)$ | $v(t)=m^{-1}p(t)$
  $w(t)=\begin{bmatrix}\mathbf{w}(t) & 0\end{bmatrix}$ | $v(t)=\dot{r}(t)$
  $\frac{1}{2}w(t)q(t)=\dot{q}(t)$ |
