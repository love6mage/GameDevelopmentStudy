# Collision and Rigid Body Dynamics

## Do You Want Physics in Your Game

- `collision detection system` 碰撞检测系统，游戏引擎的核心组件之一，确保物体不会相互穿过，通常与物理引擎（`physics engine`）紧密集成
- `Rigid body dynamics simulation` 刚体动态模拟。物理学领域是巨大的，现在大多数游戏引擎称呼为“物理学（`physics`）”的东西描述为刚体动态模拟更准确

### Things You Can Do with a Physics System

- 检测动态物体和静态世界几何之间的碰撞
- 模拟受重力和其他力影响的自由刚体
- `Spring-mass systems` 弹簧质点系统
- 可破坏的建筑物和结构
- 射线和形状（用于确定视线、子弹撞击等）
- `Trigger volumes` 触发体（决定物体何时进入、离开或位于游戏中的预定义区域）
- 复杂的机器（起重机、移动平台拼图等）
- 陷阱（如崩落的巨石）
- 具有逼真悬架的可驾驶车辆
- 布娃娃角色死亡
- `Powered rag doll` 传统动画和布娃娃物理的现实融合
- 悬垂的道具（水壶、项链、剑），半真实的头发，衣服的动作
- 布料模拟
- 水面模拟和浮力
- 音频传播
- ...
- 物理模拟可以运行时执行或作为生成动画片段的离线预处理步骤执行，例如 Maya 中有大量可用的物理插件

### Is Physics Fun

- `Simulations (Sims)` 模拟游戏的主要目标是重现真实的体验，例如飞行模拟器、GT 赛车、纳斯卡赛车系列游戏，刚体动力学系统提供的真实性非常适合这类游戏
- `Physics Puzzle Games` 物理益智游戏的主要想法是让用户玩动态模拟玩具，这种游戏的核心机制几乎完全依赖于物理学，例如 Bridge Builder、不可思议的机器、奇妙装置、蜡笔物理学
- `Sandbox Games` 沙盒游戏中，可能根本没有目标，或者可能存在大量可选目标，玩家的主要目标通常是“乱搞”和探索游戏世界中的物体可以做什么，例如侠盗猎车手 5、孢子、小小大星球 2、撕纸小邮差、我的世界。沙盒游戏可以很好地使用真实动态模拟，尤其是如果许多乐趣来源于游戏世界中物体间的真实或半真实交互。有时动态模拟可能通过各种方式微调以实现正确的感觉或增加乐趣因素，如比真实大的爆炸，比正常更强或更弱的重力
- `Goal-Based and Story-Driven Games` 基于目标的游戏有规则和玩家必须完成以推动进度的特定目标，故事驱动的游戏中讲故事至关重要。将物理系统集成到这类游戏中十分棘手。我们通常会放弃控制以换取逼真的模拟，这种失控会抑制玩家完成目标和游戏讲述故事的能力。开发者必须小心应用物理并采取措施以各种方式控制模拟的行为，以确保它不阻碍游戏玩法。为玩家提供一个摆脱困境的方法通常也是个好主意，例如光晕系列游戏玩家可以按 X 翻转颠倒的车辆

### Impact of Physics on a Game

- `Design Impacts` 设计影响
  - `Predictability` 可预测性。将物理模拟行为从动画行为中分离的固有的混乱和多变性是不可预测性的一个来源。如果某些事情总是以具体的方式发生，通常最好使用动画，而不是尝试强迫动态模拟来产生可靠运动
  - `Tuning and control` 调整和控制。物理定律（准确建模时）是固定的，游戏中可以调整重力值或刚体恢复系数，但是调整物理参数的结果通常是间接的，难以可视化。调整力让角色向所需方向移动比调整角色行走动画难得多
  - `Emergent behaviors` 应急行为。有时物理会在游戏中引入意想不到的功能，例如军团要塞中的火箭发射器跳跃技巧，光晕中的高空爆炸疣猪，心理战中的飞行的“冲浪板”
- `Engineering Impacts` 工程影响
  - `Tools pipeline` 工具流水线。良好的碰撞/物理流水线需要时间来构建和维护
  - `User interface` 用户接口。玩家如何控制物理物体，如 Trespasser 中使用虚拟手臂握住他们，半条命 2 中使用“重力枪”
  - `Collision detection` 碰撞检测。旨在动态模拟中使用的碰撞模型比非物理驱动的可能要更详细和更精心的构造
  - `AI` 人工智能。在存在物理模拟物体的情况下，可能无法预测路径，引擎可能需要处理可以移动或爆炸的动态覆盖点
  - `Misbehaved objects` 行为不端的物体。物体由动态模拟驱动时，可能由意想不到的方式相互反弹或抖动严重。可能需要应用碰撞过滤允许物体稍微互相穿透，需要建立机制确保物体稳定并适当进入睡眠状态
  - `Rag doll physics` 布娃娃物理。布娃娃需要大量微调且通常受到在模拟中不稳定的影响。动画可能驱动角色身体的部分穿透到其他碰撞体，当角色变为布娃娃时，这些互相穿透可能造成巨大的不稳定性。需要采取措施避免这个问题
  - `Graphics` 物理学。物理驱动的运动可能影响可渲染物体的包围体（否则它们将是静态的或更可预测的），可破坏建筑和物体的存在可能使某些预计算照明和阴影方法无效
  - `Networking and multiplayer` 网络和多人游戏。不影响游戏玩法的物理效果可以独立地只在每个客户端机器上模拟，影响游戏玩法的物理效果必须在服务器上模拟并准确复制到所有客户端
  - `Record and playback` 记录和回放。记录游戏并在以后播放它，作为调试和测试辅助手段十分有用，还可以作为一个有趣的游戏功能。这个功能要求每个引擎系统以确定的方式运行
- `Art Impacts` 美术影响
  - `Additional tool and workflow complexity` 额外的工具和工作流复杂度。装配具有质量、摩擦力、约束和其他用于动态模拟的属性的物体的需求使得美术部门的工作也更加困难
  - `More-complex content` 更复杂的内容。可能需要为物体提供多个视觉相同但具有不同碰撞和动态配置的版本，例如一个原始版本和一个可破坏版本
  - `Loss of control` 失控。物理驱动物体的不可预测性使控制场景的美术构成更加困难
- `Other Impacts` 其他影响
  - `Interdisciplinary impacts` 跨学科影响。在游戏中引入动态模拟需要工程、美术、音频和设计之间的紧密合作
  - `Production impacts` 生产影响。物理学会增加项目的开发成本、技术和组织复杂度以及风险

## Collision/Physics Middleware

### I-Collide, SWIFT, V-Collide and RAPID

- `I-Collide` 是 UNC 开发的开源碰撞检测库，它可以检测凸（`convex`）体间的交叉。I-Collide 已经被更快、功能更丰富的库 `SWIFT` 取代。UNC 还开发了可以处理复杂非凸形状的碰撞检测库 `V-Collide` 和 `RAPID`。这些库无法正确地开箱即用，但是它们可以为构建功能齐全的游戏碰撞检测引擎提供良好的基础

### ODE

- `ODE` 代表“开放动力学引擎（`Open Dynamics Engine`）”，是开源的碰撞和刚体动力学 SDK。其功能集与商业产品 Havok 相近。好处是免费和完整代码可用

### Bullet

- `Bullet` 是开源的碰撞检测和物理库，用于游戏和电影行业。它的碰撞引擎集成到了它的动态模拟中，但是提供了钩子使碰撞系统可以单独使用或集成到其他物理引擎中。它支持连续碰撞检测（`continuous collision detection / CCD`），也称为碰撞时间（`time of impact / TOI`）碰撞检测，当模拟包含小且快速移动的物体时非常有帮助

### TrueAxis

- 碰撞/物理 SDK，可以免费用于非商业用途

### PhysX

- `PhysX` 最开始是由 Ageia 制作和发行的称为 Novodex 的库，作为推出他们的专用物理协处理器的战略的一部分，后被 NVIDIA 购买和改良，使它能使用 NVIDIA 的 GPU 作为协处理器运行。Ageia 和 NVIDIA 的部分营销策略是完全免费提供 SDK 的 CPU 版本，以推动物理协处理器市场向前发展。开发者可以付费获取完全源代码和根据需要定制库的能力。PhysX 现在与 APEX 绑定，APEX 是 NVIDIA 的可扩展多平台动态框架。PhysX / APEX 可用于 Windows、Linux、Mac、Android、Xbox 360、PlayStation 3、Xbox One、PlayStation 4 和 Wii

### Havok

- `Havok` 是商业物理 SDK 的黄金标准，提供了最丰富的功能集之一，并在所有支持平台上具有出色的性能特征。Havok 由一个核心碰撞/物理引擎和一些可选附加产品，包括车辆物理系统、用于建模可破坏环境的系统、一个直接集成到 Havok 布娃娃物理系统的功能齐全的动画 SDK 组成。可用于 Xbox 360、PlayStation 3、Xbox One、PlayStation 4、PlayStation Vita、Wii、Wii U、Windows 8、Android、Apple Mac 和 iOS

### Physics Abstraction Layer (PAL)

- 开源库，允许开发者在一个项目上使用多个物理 SDK，为 PhysX（Novodex）、Newton、ODE、OpenTissue、Tokamak、TrueAxis 和其他一些 SDK 提供钩子

### Digital Molecular Matter (DMM)

- Pixelux Entertainment S.A. 制作的一个独特物理引擎，使用有限元方法来模拟可变形体和易碎物体的动力学。该引擎同时具有离线和运行时组件。可以在 LucasArts 的星球大战：原力释放中看到

## The Collision Detection System

- 游戏引擎的碰撞检测系统主要目的是决定游戏世界中的任何物体是否接触。每个逻辑物体表示为一个或多个几何形状，如球形、盒形、胶囊形等，碰撞系统决定任何这些形状在任何给定时间点是否相交，所以碰撞检测系统本质上是一种美化的几何交叉测试仪
- 碰撞系统可用于多种目的：避免屏幕上不真实的视觉异常，例如物体间的相互穿透；导弹击中目标时让导弹爆炸；玩家角色通过漂浮的健康包时给予角色健康提升；等等
- 刚体动态模拟通常是碰撞系统的要求最高的客户端，用碰撞系统模拟物理逼真的行为如弹跳、滚动、滑动、静止等；但是，即使是没有物理系统的游戏仍然可以大量使用碰撞检测引擎

### Collidable Entities

- 想要游戏中的特定逻辑物体有能力与其他物体碰撞，需要给它提供一个碰撞表示（`collision representation`），描述物体的形状和在游戏世界中的位置和方向。这是一个独特的数据结构，不同于物体的游戏表示（`gameplay representation`，定义物体在游戏中的角色和行为）和视觉表示（`visual representation`，可能是三角形网格实例、细分曲面、粒子效果或其他视觉表示）
- 从检测交叉的角度看，我们通常更喜欢几何和数学简单的形状。理想情况下，只有当简单表示证明不足以在游戏中实现期望的行为时才采用更复杂的形状
- Havok 使用术语 `collidable` 描述一个可以参与碰撞检测的独特的刚体，每个 collidable 表示为 C++ 类 `hkpCollidable` 的一个实例；PhysX 称它的刚体为 `actors`，将它们表示为类 `NxActor` 的实例。两个库中可碰撞实体都包含两个基本信息：形状和变换。需要变换信息有三个原因
  - 一个形状必须变换以在自然空间中正确定位和定向
  - 移动任何复杂形状时，如果我们不得不单独移动它的所有特性（顶点、平面等），成本很高，而使用变换可以低成本移动形状，不管它的特性有多复杂
  - 描述形状的信息占用大量内存，所以允许多个可碰撞实体共享一个形状描述是有益的
- 游戏中任何特定物体可能根本没有 collidable（不需要碰撞检测）、有一个 collidable（物体是一个简单刚体）或有多个 collidable（例如每个表示铰接机器人臂的一个刚性组件）

### The Collision/Physics World

- 碰撞系统通常通过单例数据结构碰撞世界（`collision world`）跟踪它所有的可碰撞实体，碰撞世界是明确设计用于碰撞检测系统的游戏世界的一个完整表示。Havok 中碰撞世界是类 `hkpWorld` 的一个实例，PhysX 中是 `NxScene`，ODE 中是 `dSpace`
- 碰撞世界通常是表示游戏中所有可碰撞形状的几何体的层次结构的根
- 将所有碰撞信息维护在一个私有数据结构中与试图将碰撞信息保存到游戏物体本身相比有多个优点
  - 碰撞世界只需要包含潜在可能相互碰撞的物体的 Collidable，避免迭代任何不相关数据结构
  - 这个设计允许碰撞数据以可能最高效的方式组织，例如可以利用缓存一致性最大化性能
  - 碰撞世界是一种有效的封装机制，从可理解性、可维护性、可测试性、可重用性的角度看通常是一个优点
- `The Physics World` 刚体动态系统通常与碰撞系统紧密集成，通常与碰撞系统共享“世界”数据结构，模拟中的每个刚体通常与碰撞系统中的一个 Collidable 关联。这种设计在物理引擎中很常见，因为物理系统需要频繁和详细的碰撞查询。通常由物理系统实际驱动碰撞系统的操作，每个模拟时间步骤指示它执行碰撞测试最少一次，或有时多次，因此碰撞世界通常称为碰撞/物理世界（`collision/physics world`）或有时仅称为物理世界（`physics world`）
- 动态模拟中每个动态刚体通常与碰撞系统中的一个 Collidable 关联，尽管不是所有 Collidable 都需要动态刚体。例如 Havok 中刚体表示为 `hkpRigidBody` 的实例，每个刚体有一个指向一个 `hkpCollidable` 的指针；PhysX 中 Collidable 和刚体的概念混合在一起，`NxActor` 类用于这两个目的，尽管刚体的物理属性单独保存在 `NxBodyDesc` 实例中。两个 SDK 中都可以告诉刚体它的位置和方向在空间中固定，意味着他们将被动态模拟省略，只作为一个 Collidable
- 尽管紧密集成，大多数物理 SDK 确实至少做过尝试将碰撞库与刚体动态模拟分开。这允许碰撞系统作为独立库使用，对于不需要物理但需要检测碰撞的游戏十分重要；也意味着游戏工作室理论上可以完全替换一个物理 SDK 的碰撞系统而不需要重写动态模拟，这实际上比听起来要难

### Shape Concepts

- 丰富的数学理论是日常形状概念的基础。可以将形状想象为由边界描述的一个空间区域，有明确的内部和外部。二维空间中，形状有区域，边界由曲线或多条边（多边形）定义；三维空间中，形状有体积，边界由曲面或多边形（多面体）定义
- 有些游戏物体，例如地形、河或薄壁，可能最好用表面表示，三维空间中，表面是二维几何体，有前和后，但是没有内部或外部。许多碰撞 SDK 提供对表面基元的支持，扩展形状的概念以包括封闭体积和开放表面
- 碰撞库通常允许表面通过可选的挤出参数给定体积，这样的参数定义表面的“厚度”，有助于减少小且快速移动的物体与无限薄的表面间错过碰撞的发生
- 碰撞系统通常打包接触信息到一个数据结构内，例如 Havok 将接触作为 `hkContactPoint` 类的实例返回。接触信息通常包含一个分离向量（`separating vector`），沿这个向量移动物体可以使其有效地从碰撞中移开；通常还包含接触的两个 Collidable 的信息：哪些形状相交，甚至这些形状的哪些特性接触。系统可能还返回额外的信息，例如投射到分离法线上的物体速度
- `Convexity` 凸和非凸形状是一个重要分别，通常凸形状间比凹形状间的碰撞检测更简单且计算密度更低

### Collision Primitives

- `Spheres` 球，最简单的三维体，最高效的碰撞元，由一个中心点和一个半径表示，可以方便装到一个四元浮点向量中
- `Capsules` 胶囊，一个圆柱和两个半球端盖组成，通常由两个点和一个半径表示，比圆柱和盒高效
- `Axis-Aligned Bounding Boxes (AABB)` 轴对齐包围盒，每个面都与坐标轴平行，由两个点定义：一个包含盒沿每个主轴的最小坐标，一个包含最大坐标。优点是盒间的交叉测试十分高效，缺点是物体旋转后需要重计算包围盒，且包围盒可能与物体形状相似度极差
- `Oriented Bounding Boxes (OBB)` 方向包围盒，可以相对于其坐标系旋转，通常由三个长度（半宽、半深、半高）和一个变换（定位和定向盒中心点）表示
- `Discrete Oriented Polytopes (DOP)` 离散定向多面体，是 AABB 和 OBB 的更一般情况，是凸多面体。AABB 和 OBB 都是 6-DOP。构造 DOP 通常的方法是先构造一个 OBB，然后使用额外的平面将边或角倾斜 45 度
- `Arbitrary Convex Volumes` 任意凸体，大多数碰撞引擎允许 3D 美术师在像 Maya 这样的包中构造任意凸体，离线工具分析凸体的三角形，确保他们形成一个凸多面体，然后这些三角形被转化为平面集，表示为 k 个平面方程，或 k 个点和 k 个法线向量
- `Polygon Soup / Poly Soup` 多边形集合，一些碰撞系统也支持完全任意的非凸形状，称为多边形集合，常用于建模复杂的静态几何，如地形和建筑
  - 多边形集合的碰撞检测是最耗时的，必须测试每个三角形，并正确处理相邻三角形共享边的假交点，所以大多数游戏尝试限制多边形集合的使用，使其不参与动态模拟
  - 多边形集合不需要表示体积，即表示一个开放表面。可以使用三角形绕序提供表面的前后信息或体的内外信息；也可以伪造开放表面的内外部，例如用多边形集合表示地势时，可以判断任意表面的前面总是指向远离地球的地方
- `Compound Shapes` 复合形状，对于非凸物体的建模，通常可以是多边形集合的更有效的替代，多个凸体通常可以胜过单个多边形集合。一些碰撞系统可以在测试碰撞时利用复合形状作为一个整体的凸包围体，在 Havok 中称为中期碰撞检测（`midphase collision detection`），复合形状的凸包围体测试如果不相交，则系统根本不需要测试子形状的碰撞

### Collision Testing and Analytical Geometry

- 碰撞系统可以使用解析几何（`analytical geometry`，三维体和面的数学表示）在计算上检测形状间的相交
- `Point versus Sphere` 判断点是否在球中，可以简单比较点到球心的距离与球半径
- `Sphere versus Sphere` 判断两球是否相交，可以简单比较两球心的距离与两球半径的和
  - 为避免计算距离的平方根操作，可以将距离的比较转化为距离的平方的比较
- `The Separating Axis Theorem` 分离轴定理，被大多数碰撞系统大量使用。它指出，如果可以找到一个轴，使得两个凸形状在这个轴上的投影不重叠，则这两个形状不相交
  - 二维空间中，如果可以找到一条线，使得形状 A 完全在线的一边，形状 B 完全在线的另一边，则 A 和 B 不相交，这条线称为分界线（`separating line`），分界线总是与分离轴垂直
  - 某些类型的形状具有使潜在分离轴明显的属性，可以将两个形状轮流投影在这些潜在分离轴上，然后检查投影区间是否重叠
- `AABB versus AABB` AABB 间的相交可以简单应用分离轴定理判断
- `Detecting Convex Collisions: The GJK Algorithm` 检测凸形状碰撞的 GJK 算法
  - `Minkowski difference` Minkowski 差，形状 B 内每个点与形状 A 内每个点的差的集合。当两个形状都是凸形状时，这个集合中包含原点，当且仅当两个形状相交。两个凸形状的 Minkowski 差本身也是一个凸形状
  - `Simplex` 单形，是一组点，一个点的单形是点，两个点的单形是线段，三个点的单形是三角形，四个点的单形是四面体（`tetrahedron`）
  - GJK 算法利用了 Minkowski 差，但是只关心差的凸包（`convex hull`），而不是内部所有点，GJK 的主要过程就是尝试去找位于凸包上且包含原点的四面体，找得到则形状相交，否则不相交。GJK 是迭代算法，开始于 Minkowski 差凸包上任意一点，即一个点的单形，尝试构建可能包含原点的更高阶单形。在每个迭代中，查看当前已有的单形，判断原点位于单形的哪个方向，在该方向上找到支持顶点即离原点最近的凸包上的点，将该点加入当前单形来创建更高阶的单形。如果新创建的单形包含原点，则算法结束，两形状相交；如果无法找到支持顶点，则两形状不相交
- `Other Shape-Shape Combinations` 形状间的绑定数量非常大，对于 $N$ 个形状类型，需要按对测试的数量为 $O(N^2)$，这是碰撞引擎通常限制基元数量的一个原因，也是 GJK 算法流行的原因：它一举处理所有凸形状类型间的碰撞检测。
  - 给定任意两个形状，需要选择合适的碰撞测试函数。许多碰撞引擎使用双重调度（`double dispatch`）方法，通常使用二维函数查找表实现，查找关键字是要测试的物体的形状类型；也可以实现为安排基于物体 A 的虚函数调用基于物体 B 的虚函数
- `Detecting Collisions between Moving Bodies` 游戏中的动作通常在离散的时间步骤中模拟，当物体小且高速移动时，每个时间步骤间覆盖的距离远大于它的尺寸。碰撞世界两次连续快照中快速移动物体的图像中间会有一个间隙，如果其他物体刚好在这个间隙中，会完全错过碰撞，这个问题称为“子弹穿过纸张（`bullet through paper`）”问题或者“隧道（`tunneling`）”问题
  - `Swept Shapes` 可以使用扫掠形状避免隧道问题。扫掠形状是一个形状从一个点到另一个点的运动形成的新形状，例如一个扫掠球是一个胶囊形状。可以测试物体从前一个快照的位置和方向移动到当前快照的位置和方向形成的扫掠形状，而不是测试碰撞世界的静态快照。这相当于在快照间线性插值可碰撞物的运动，但是线性插值不适用于沿曲线运动或自旋转的物体，这两种情况下物体运动的扫掠形状可能是非凸形状
  - `Continuous Collision Detection (CCD)` 连续碰撞检测，CCD 的目的是找到给定时间间隔内两个移动物体间的最早影响时间（`time of impact / TOI`）。CCD 算法本质上通常是迭代的，对于每个可碰撞物，维护它前一个时间步骤和当前时间的位置和方向，用于独立地线性插值位置和旋转，产生可碰撞物在前一个和当前时间步骤间任意时间点的变换的近似，然后在运动路径上查找最早 TOI。通常使用很多查找算法，包括 Brian Mirtich 的 conservative advancement 方法

### Performance Optimizations

- 判断两个形状相交需要的计算很耗时，且大多数游戏世界包含大量物体，当物体数量增加时所需的碰撞测试数急剧增长
- `Temporal Coherency / frame-to-frame coherency` 利用时间一致性：当可碰撞物以合理速度移动时，它们的位置和方向在时间步骤间通常十分相似。通常可以通过跨多个时间步骤缓存结果来避免每帧重新计算某些类型的信息
- `Spatial Partitioning` 空间划分，将空间分为一些小区域，如果一对可碰撞物不出现在同一区域，则不需要为它们执行具体的碰撞测试，显著减少所需的碰撞测试数。可以使用各种层次划分模式，例如八叉树、BSP、kd-tree、球树等，树的一个分支上的物体不能与其它兄弟分支上的物体碰撞
- `Broad Phase, Midphase and Narrow Phase` Havok 使用三层方法修剪需要测试碰撞的可碰撞物集合
  - `Broad Phase` 粗略阶段，使用总的 AABB 测试判断可碰撞物是否潜在相交
    - `The Sweep and Prune Algorithm` 扫描和修剪算法，按三个主轴对可碰撞物的 AABB 的最小和最大坐标进行排序，然后遍历排序列表检查重叠的 AABB。该算法可以使用帧间一致性将 $O(n\log{n})$ 的排序操作减少到 $O(n)$ 的预期执行时间
  - `Midphase` 中间阶段，测试复合类型的粗略包围体
  - `Narrow Phase` 细测阶段，测试各可碰撞物的基元
