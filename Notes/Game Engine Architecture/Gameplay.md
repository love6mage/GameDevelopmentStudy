# Gameplay

## Introduction to Gameplay Systems

- 游戏玩法可以定义为玩游戏的整体体验。游戏机制（`game mechanics`）是游戏玩法更具体的说法，通常定义为一组管理游戏中各种实体间交互的规则，还定义玩家目标、胜利或失败标准、玩家角色能力、非玩家实体的数量和类型、游戏体验的整体流程等
- 论文 “A Survey of ‘Game’ Portability” 中将用于实现游戏玩法的软件系统集合称为 `G-factor`

### Anatomy of a Game World

#### World Elements

- 组成游戏世界的离散元素分为静态元素和动态元素
- 实现游戏玩法的软件系统主要关注动态元素的状态，游戏状态（`game state`）指作为一个整体的所有动态元素的当前状态
- 静态元素与动态元素的分别通常有点模糊（如具有可破坏环境的游戏），它们的分别主要用作优化工具
- `Static Geometry` 静态元素几何通常在 Maya 这样的工具中定义，组建游戏世界的静态部分时可以实例化多次
  - `Brush geometry` 画笔几何，来源于 Quake 引擎家族，可以构建静态元素和碰撞数据。一个画笔将一个形状描述为一组凸体，每个凸体以一组平面为界。画笔几何可以快速简单地创建和集成到基于 BSP 树的渲染引擎中。画笔对于快速组成游戏世界的内容非常有用，允许游戏玩法尽早进行测试。如果布局有价值，美术团队可以对画笔几何进行纹理映射和微调，或者将其替换为更详细的自定义网格资产；如果布局需要重新设计，画笔几何可以很容易地修改

#### World Chunks

- 大的虚拟游戏世界通常分为离散的可玩区域，称为世界块（`world chunks`），块也称为关卡（`levels`）、地图（`maps`）、阶段（`stage`）或区域（`areas`）
- 最初，关卡的概念用于在早期游戏硬件的有限内存中提供游戏玩法的变化；现在这个概念在许多方向分支，有些游戏块间界限并不明显，有些游戏使用星型拓扑，有些游戏使用图拓扑，有些游戏使用 LOD 技术提供一个广阔、开放世界的幻想
- 现在许多游戏世界仍然分为某种块
  - 内存限制仍然是重要约束
  - 块是控制游戏整体流程的方便的机制
  - 块可以用作分工机制

#### High-Level Game Flow

- 游戏的高级流程定义玩家目标的一个序列、树或图，目标有时称为任务（`tasks`）、阶段（`stages`）、关卡（`level`）或波（`waves`，如果游戏主要关于击败成群的敌人）。高级流程还提供每个目标成功的定义和失败的惩罚，在故事驱动游戏中还包含各种游戏内电影
- 早期游戏玩家目标与世界块一一对应，现在这种对应很少，一个目标可以关联多个块，且耦合很松，这种设计提供了独立改变游戏目标和世界划分的灵活性。许多游戏将目标分为粗略的游戏部分，通常称为章（`chapters`）或幕（`acts`）

  ![GameObjectives](Images/GameObjectives.PNG)

### Implementing Dynamic Elements: Game Objects

- 动态元素通常设计为面向对象风格，可以用游戏物体（`game object / GO`）指代游戏世界中几乎任何动态元素，游戏物体通常也称为实体（`entities`）、行动者（`actors`）或代理（`agents`）等

#### Game Object Models

- 计算机科学中，术语对象模型有两个相关但是不同的意思
  - 可以指特定编程语言或正式设计语言提供的一组功能，例如 C++ 对象模型或 OMT 对象模型
  - 可以指特定面向对象编程接口，即设计为解决特定问题的一组类、方法和相互关系，例如 Microsoft Excel 对象模型
- 可以用游戏对象模型描述游戏引擎提供的能力，以允许建模和模拟虚拟游戏世界中的动态实体，因此，游戏对象模型有上面给出的两个定义的方面
  - 是特定面向对象编程接口，解决特定问题：模拟组成游戏的一组特定实体
  - 通常扩展编写引擎的编程语言。如果游戏用非面向对象语言如 C 实现，面向对象的能力可以通过程序员添加；如果用面向对象语言如 C++ 实现，通常会添加反射、持久化和网络复制等高级特性。游戏对象模型有时融合多个语言的特性

#### Tool-Side Design versus Runtime Design

- 几乎所有的游戏引擎有某种形式的工具端对象模型和该对象模型的相应运行时实现
  - 工具端对象模型由世界编辑器中设计师看到的一组游戏对象类型定义
  - 运行时对象模型由程序员用于运行时实现工具端对象模型的一组语言结构和软件系统定义，可能与工具端对象模型完全相同或直接映射到它，也可能与工具端对象模型完全不同

### Data-Driven Game Engines

- 当游戏的行为可以由美术师和设计师提供的数据而不是完全由程序员制作的软件全部或部分控制时，我们称引擎为数据驱动的
- 数据驱动架构可以提高团队效率和迭代时间，但是数据驱动特性通常付出了巨大代价，游戏引擎在何时选择引擎的哪些方面进行数据驱动要极度小心，权衡创建数据驱动或快速迭代特性的成本与该特性在整个项目期间期望节省的时间，并且在设计和实现数据驱动工具和引擎系统时坚持 KISS (“keep it simple, stupid”) 口头禅

### The Game World Editor

- 数据驱动的资产创建工具，如 Maya、Photoshop、Havok 内容工具等，在游戏空间中的模拟是游戏世界编辑器：允许游戏世界块由静态和动态元素定义和填充的一个或一套工具
- 所有商业游戏引擎都有某种世界编辑器工具
  - Radiant，用于为 Quake 和 Doom 引擎家族创建地图
  - Hammer，之前用名称 Worldcraft 和 The Forge 发布的编辑器，由 Valve 的 Source 引擎提供
  - CryENGINE 3 的沙盒编辑器

#### Typical Features of a Game World Editor

- `World Chunk Creation and Management` 世界创建的单元通常是块，游戏世界编辑器通常允许创建新块，重命名、分割、合并或销毁已有块
  - 每个块可以链接到一个或多个静态网格或其他静态数据元素如 AI 导航地图、玩家可以抓取的壁架的描述、掩护点定义等
  - 一些引擎中，块由单个背景网格定义，没有一个就无法存在；其他引擎中，块可以单独存在，可能由包围体定义，且可以用零个或多个网格或画笔几何填充
  - 一些世界编辑器提供专门的工具创作地形、水和其他特殊静态元素；其他引擎中，这些元素可以使用标准 DCC 应用程序创作，但以某种方式标记指示资产调节流水线或运行时引擎它是特殊的，例如神秘海域和最后生还者中水创作为三角网格，但用一个特殊材质映射指示它被视为水
  - 有时，特殊的世界元素在单独的独立工具中创建和编辑，例如荣耀勋章：血战太平洋中的高度场地图用从 EA 中另一个团队获得的自定义工具版本创作，而不是将地形编辑器集成到 Radiant 中
- `Game World Visualization` 几乎所有的世界编辑器通过某种方式提供世界的一个三维透视图或二维正交投影
  - 直接集成一个自定义渲染引擎到编辑器
  - 编辑器自身集成到 3D 几何编辑器如 Maya 或 3ds Max 中
  - 编辑器与真实的游戏引擎通信，用它渲染三维透视图
  - 编辑器集成到引擎中
- `Navigation` 一些编辑器提供导航的一系列便利功能，包括
  - 选定和聚焦一个物体
  - 保存各种相关摄像头位置，然后在它们之间跳转
  - 各种摄像头移动速度模式，用于粗略导航和精细摄像头控制
  - 类似 Web 浏览器的导航历史记录，用于在游戏世界中跳转等等
- `Selection` 世界编辑器的用户需要能单独选定元素来进行编辑
  - 可以通过正交视图中的橡皮筋盒或者三维视图中的射线投射风格拾取选定物体
  - 许多编辑器还显示所有世界元素的滚动列表或树视图，这样物体可以通过名称查找和选定
  - 一些编辑器还允许命名和保存选定，供以后恢复
  - 游戏世界物体分布密集时物体选定有时很困难。当使用射线投射选定物体时，可以允许用户循环遍历射线当前相交的所有物体，或者允许暂时隐藏当前选定物体
- `Layers` 一些编辑器允许物体分组为预先定义或用户定义的层，整个层可以隐藏或显示，可以作为分工策略的重要部分
- `Property Grid` 世界元素通常有各种用户编辑的属性，属性可以是简单的键值对，或更复杂的数据数组、嵌套的复合数据结构。大多数世界编辑器在一个滚动属性网格视图中显示当前选定物体的属性
  - `Editing Multiobject Selections` 可以选定多个物体的编辑器中，多个物体选中时编辑器只显示物体共有的属性
  - `Free-Form Properties` 物体关联的属性和这些属性的数据类型一般基于每个物体类型定义，一些编辑器允许用户基于每个实例定义额外的“自由格式”属性，这些属性通常实现为键值对的扁平表，用户可以自由选择每个自由格式属性的名称、数据类型和值
- `Object Placement and Alignment Aids` 世界编辑器以特殊方式处理一些物体属性，例如位置、方向、缩放、资产链接等，许多世界编辑器在基本平移、旋转和缩放工具外提供大量物体放置和对齐辅助工具，这些功能大量借鉴商业图形和 3D 建模工具如 Photoshop、Maya、Visio 等的功能集，包括捕捉到网格、捕捉到地形、对齐到物体等
- `Special Object Types` 特定物体类型也需要特殊处理
  - `Lights` 光源，通常使用特殊图标表示，因为它们没有网格，编辑器可能尝试显示光源的大概效果
  - `Particle emitters` 构建在独立渲染引擎上的编辑器中，粒子效果的可视化比较困难，因此粒子发射器可能只用图标显示，或尝试在编辑器中模仿粒子效果。如果编辑器在游戏中或可以与运行中游戏通信，则这不是问题
  - `Sound sources` 3D 渲染引擎将声源建模为 3D 点或体，为它们提供专门的编辑工具十分方便，例如可视化全向发声器的最大半径或定向发声器的方向向量和椎体
  - `Regions` 是一个用于检测相关事件的空间体，可以建模为球、定向盒、k-DOP 等。如果区域总是球形的，可以使用“半径”属性；但是为了定义和修改任意形状的区域，几乎肯定需要一个特殊的编辑工具
  - `Splines` 世界编辑器通常需要提供显示样条的能力，用户可以选定和操作样条的个别控制点。一些编辑器支持两种选择模式，一个“粗略”模式用于选定物体，一个“详细”模式用于选定已选中物体的个别组件
  - `Nav meshes for AI` 许多游戏中，NPC 通过在游戏世界的可导航区域内执行寻路算法导航，这些可导航区域必须定义，在编辑器中创建、可视化和编辑，例如导航网格是一个二维三角网格，提供可导航区域边界的简单描述以及连接信息
  - `Other custom data` 每个游戏有自己的具体数据要求，世界编辑器可能被要求提供这些数据的可视化和编辑能力，例如游戏空间中供 AI 系统使用的“联觉效应”的描述（窗口、门口、可能的攻击或防御点），描述一些东西如玩家角色或 NPC 使用的掩护点或可抓取壁架的几何特征
- `Saving and Loading World Chunks` 引擎间加载和保存世界块的粒度不同，一些按块，一些按层；数据格式也不同，一些使用自定义二进制格式，一些使用文本格式如 XML 或 JSON
- `Rapid Iteration` 好的游戏世界编辑器通常支持一定程度的动态调整以快速迭代

#### Integrated Asset Management Tools

- 一些引擎中，游戏世界编辑器集成了游戏资产数据库管理的其他方面，例如定义网格和材质属性、定义动画、混合树、动画状态机、设置物体的碰撞和物理属性、管理纹理资源等
- 这个设计比较著名的一个例子是 UnrealEd，构建在 Unreal 引擎上的游戏用于创建内容的编辑器
- `Data Processing Costs` 游戏资产从源格式转化到游戏引擎所需格式通常有两步处理，首先，资产从 DCC 应用程序导出为平台无关的中间格式，然后，资产处理为针对特定平台进行了优化的格式
  - 工具流水线间的一个关键不同是平台特定优化步骤的执行点。UnrealEd 在资产首次导入编辑器时执行，这在快速迭代中得到回报，但更改源资产十分痛苦；其他引擎如 Source 引擎和 Quake 引擎在游戏运行前烘焙关卡时进行资产优化；Halo 为用户提供随时更改原始资产的选项

## Runtime Gameplay Foundation Systems
