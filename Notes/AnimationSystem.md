# Animation System

## Types of Character Animation

### Cel Animation

- `traditional animation` / `hand-drawn animation` 传统动画 / 手绘动画，所有游戏动画技术的先导，用于最早的动画片，通过快速连续地显示称为帧（`frame`）的一系列静止图像来产生运动的错觉。实时 3D 渲染可以被认为是传统动画的电子格式
- `Cel Animation` Cel 动画，一种特殊的传统动画。一个 Cel 是一个可以在其上绘制图像的塑料透明薄片。可以将动画的 Cel 序列放在固定的背景之上以产生运动的幻觉，而不必反复重绘静态背景
- `Sprite Animation` 精灵动画，Cel 动画的电子格式。一个精灵是一个可以覆盖在全屏背景图像上且不破坏它的小位图，通常由专门的图形硬件协助绘制。所以，精灵之于 2D 游戏动画等同 Cel 之于传统动画
- `looping animation` 循环动画，帧序列被设计为即使在无限重复时也能平滑地动画化。人物通常具有许多循环动画周期，包括各种空闲周期（`idle cycles`）、一个步行周期（`walk cycle`）、一个奔跑周期（`run cycle`）

### Rigid Hierarchical Animation

- 随着 3D 图形的出现，精灵技术开始失去吸引力。*毁灭战士*使用了一个类精灵动画系统：它的怪物只是面向相机的四边形，每个四边形显示一系列纹理位图（`animated texture`）来产生运动幻觉。这个技术至今仍用于低分辨率和遥远的物体
- `Rigid hierarchical animation` 刚体分层动画，3D 人物动画最早的方法。这个方法中，人物使用一个刚体件集合建模，这些刚体件以分层方式彼此约束，类似于哺乳动物的骨骼通过关节连接。该方法最大的问题是关节处的开裂问题，对于机器人和机械效果很好，但不适用与鲜活丰满的人物。一个典型的分层结构如下
  - 骨盆
    - 躯干
      - 上右臂
        - 下右臂
          - 右手
      - 上左臂
        - 下左臂
          - 左手
    - 上右腿
      - 下右腿
        - 右脚
    - 上左腿
      - 下左腿
        - 左脚

### Per-Vertex Animation and Morph Targets

- `Per-vertex animation` 每顶点动画，网格顶点由美术师动画化，运动数据导出用于描述运行时顶点如何运动。这个技术可以产生任何可以想象的网格变形，但是一个数据密集型技术，要为每个顶点保存时变运动信息，所以很少应用于实时游戏
- `Morph target animation` 变形目标动画，每顶点动画的变体。网格顶点由动画师移动，以创建一组相对较小的固定极端姿势。运行时可以混合两个或多个这些固定的姿势产生动画。每个顶点的位置可以使用每个极端姿势中顶点位置间的简单线性插值来计算，常用于面部动画
  - 一些工作室使用包含数百个关节的关节面部装备替换变形目标；另一些工作室则结合这两种技术，使用关节装备实现面部的主要姿势，然后通过变形目标应用微调

### Skinned Animation

- `skinned / skeletal animation` 蒙皮 / 骨骼动画，像刚体分层动画一样由刚性的“骨头”构造一个骨架（`skeleton`），但是不会直接渲染这些刚体件，而是让他们保持隐藏，在其上覆盖平滑连续的三角形网格，这些网格称为蒙皮（`skin`），与骨架的关节绑定，其顶点跟踪关节的运动。蒙皮网格的每个顶点可以加权到多个关节，所以当关节移动时，蒙皮可以以自然的方式伸展
- 骨骼动画可以像每顶点动画一样允许网格三角形变形，还享有刚体分层动画的更高的性能和内存使用特性，首先用于*超级马里奥 64*，至今仍然被游戏产业和故事片行业广泛使用。众多著名的现代游戏和电影角色全部或部分使用了蒙皮动画技术进行动画制作，包括*侏罗纪公园*中的恐龙，*合金装备4*中的 Solid Snake，*魔戒*中的咕噜，*神秘海域*中的 Nathan Drake，*玩具总动员*中的巴斯光年，*战争机器*中的 Marcus Fenix，*最后生还者*中的 Joel

### Animation Methods as Data Compression Techniques

- 最灵活的动画系统可以让动画师控制对象表面上每个无穷小的点，当然，像这样的动画会导致动画可能包含无限量的数据。每顶点动画、变形目标动画、蒙皮动画实际上可以看做是对这些无限量数据的压缩。我们通常的目标就是选择一个不会产生不可接受的视觉伪影的、提供最佳压缩的动画方法。
- 人物四肢大多数情况下像刚体一样随骨骼高效移动，这种情况下骨骼动画提供了最佳压缩；但是面部运动更加复杂，顶点的运动更独立，如果使用骨骼动画令人信服地动画化面部，则关节的数量趋近于顶点的数量，这减弱了其作为压缩算法的有效性。面部的动画使用变形目标压缩效果更好，因为顶点被约束为仅沿固定数量的预定义顶点位置之间的线性路径移动，而且变形目标往往是动画师工作的一种更自然的方式

## Skeletons

- 骨骼由称为关节（`joints`）的刚性件的层次结构组成。在游戏行业中，我们经常互换地使用术语关节和骨头（`bone`），但术语骨头实际上用词不当。从技术上讲，关节是动画师直接操作的物体，而骨头只是关节间的空白空间，游戏引擎不关心骨头，只有关节很重要。所以行业中使用“骨头”一词实际上 99% 是指关节。

### The Skeleal Hierarchy

- 骨骼动画的骨骼层次结构由关节组成，与典型的刚体层次结构看起来几乎相同
- 一个人形角色的关节层次结构可能如下，每个关节只有一个父亲，所以可以通过存储每个关节的父亲索引完全描述这个层级结构
  - 骨盆
    - 下脊椎
      - 中脊椎
        - 上脊椎
          - 右肩
            - 右肘
              - 右手
                - 右拇指
                - 右食指
                - 右中指
                - 右无名指
                - 右小指
          - 左肩
            - 左肘
              - 左手
                - 左拇指
                - 左食指
                - 左中指
                - 左无名指
                - 左小指
          - 颈部
            - 头
              - 左眼
              - 右眼
              - 各种面关节
    - 右大腿
      - 右膝盖
        - 右脚踝
    - 左大腿
      - 左膝盖
        - 左脚踝

### Representing a Skeleton in Memory

- 通常由一个小的顶部数据结构表示，该结构包含各个关节的数据结构数据
- 关节通常按顺序列出，以确保子关节始终出现在数组中的父关节之后，所以关节 0 总是骨架的根
- `Joint indices` 关节索引，通常用于指向动画数据结构中的关节。该方法在存储方面和查询一个关节的速度方面更高效
- 每个关节数据结构通常包含的信息
  - 关节名，一个字符串或一个散列 32 位字符串 ID
  - 父关节的索引
  - `inverse bind pose transform` 逆绑定姿势变换。关节的绑定姿势是该关节绑定到蒙皮网格顶点时的位置、方向、缩放
- 一个典型的骨架数据结构

  ```C
  struct Joint
  {
    Matrix4x3 m_invBindPose; // inverse bind pose transform
    const char* m_name; // human-readable joint name
    U8 m_iParent; // parent index or 0xFF if root
  };
  struct Skeleton
  {
    U32 m_jointCount; // number of joints
    Joint* m_aJoint; // array of joints
  };
  ```

## Poses

- 姿势是动画师给人物注入生命的主要工具，动画就是将角色的身体排列成一系列离散的静止姿势然后快速连续显示（通常在相邻姿势间线性插值而不是逐个显示姿势）
- 关节的姿势由关节的位置、方向和缩放定义，相对于某些参考帧。关节姿势通常用 $4\times 4$ 或 $4\times 3$ 矩阵或 SQT 数据结构（scale, quaternion rotation and vector translation）表示。骨架的姿势是关节姿势的集合，用一个简单的矩阵或 SQT 的数组表示

### Bind Pose

- `Bind pose` / `Reference pose` / `Rest pose` 绑定姿势，绑定到骨架前的 3D 网格的姿势。也称为 T 姿势（`T-pose`），因为人物通常站立时双脚略微分开，双臂伸出，形成字母 T 的形状

### Local Poses

- 关节的姿势通常相对于其父关节定义，我们通常使用术语局部姿势来描述相对于父关节的姿势。局部姿势大多数保存为 SQT 格式
- `Joint space` 关节空间，一个关节定义的坐标空间
- 一个关节姿势只不过是一个仿射变换，关节 $j$ 的姿势可以写成 $4\times 4$ 的仿射变换矩阵 $P_j$，由平移矢量 $T_j$，$3\times 3$ 的对角缩放矩阵 $S_j$，$3\times 3$ 的旋转矩阵 $R_j$ 组成。整个骨架的姿势 $P^{skel}$ 可以写成所有姿势 $P_j$ 的集合
  
  $$
  P_j=\begin{bmatrix}
    S_jR_j & 0 \\
    T_j & 1
  \end{bmatrix},\quad
  P^{skel}=\{P_j\}|_{j=0}^{N-1}
  $$

- `Joint Scale` 关节缩放
  - 有些引擎假设关节不会被缩放，所以 $S_j$ 被简单地省略并假设为单位矩阵
  - 有些引擎假设关节只会被均匀缩放（`uniform scale`），所以缩放可以用单个标量 $s_j$ 表示
  - 有些引擎允许非均匀缩放（`nonuniform scale`），所以缩放可以紧凑表示为三元向量 $s_j=\begin{bmatrix} s_{jx} & s_{jy} & s_{jz}\end{bmatrix}$。它对应 $S_j$ 的三个对角线元素，所以本身并不真的是一个向量
  - 几乎所有引擎不允许切变，因为切变需要一个完整的 $3\times 3$ 切变矩阵表示
  - 对缩放的省略或约束减少了内存使用，简化了数学逻辑和引擎处理
- `Representing a Joint Pose in Memory` 关节姿势在内存中的表示，通常以 SQT 格式保存，在 C++ 中的数据结构可能如下，S 被放在最后以优化结构体包装

  ```C++
  struct JointPose
  {
    Quaternion m_rot; // Q
    Vector3 m_trans; // T
    F32 m_scale; // S (uniform scale only)
    // Vector4 m_scale; // S (nonuniform scale is permitted)
  };
  struct SkeletonPose
  {
    Skeleton* m_pSkeleton; // skeleton + num joints
    JointPose* m_aLocalPose; // local joint poses
  };
  ```

- `The Joint Pose as a Change of Basis` 任何仿射变换可以认为是点或向量从一个坐标空间向另一个坐标空间的变换。关节姿势变换 $P_j$ 应用于表示在关节 j 空间中的点或向量，结果是表示在父关节空间中的该点或向量，所以关节 j 的局部姿势可以写作 $P_{j\to p(j)}$，其中 $p(j)$ 返回关节 j 的父关节索引

### Global Poses

- 有时在模型或自然空间中表示关节姿势十分方便，这称为全局姿势。关节的全局姿势可以这样计算：在骨架中从当前关节到根关节进行遍历，将路径上所有关节的局部姿势串联相乘

  $$
  P_{j\to M}=\prod_{i=j}^0P_{i\to p(i)}
  $$

- `Representing a Global Pose in Memory` 全局姿势在内存中的表示，扩展 `SkeletonPose` 结构体，使其包含全局姿势

  ```C++
  struct SkeletonPose
  {
    Skeleton* m_pSkeleton; // skeleton + num joints
    JointPose* m_aLocalPose; // local joint poses
    Matrix44* m_aGlobalPose; // global joint poses
  };
  ```

## Clips

- 游戏是互动体验，游戏人物的运动不是像电影一样的长连续帧序列，而是被细分为大量细粒度的动作，这些单独的动作称为动画片段（`animation clips`）或有时仅称为动画（`animation`）
- 每个片段使人物执行一个明确定义的动作，有些设计为循环的，如步行周期或奔跑周期，有些设计为执行一次，如抛物或绊倒在地上；有些影响整个身体，如人物跳到空中，有些只影响身体的一部分，如挥动右臂
- 游戏的不互动部分包含了特殊情况，称为游戏中的电影（`in-game cinematic / IGC`）、非交互序列（`noninteractive sequence / NIC`）或全动态视频（`full-motion video / FMV`）。他们通常用于交代故事元素，采用和电影一样的方式创建。`IGC` 和 `NIS` 通常指游戏引擎自己实时渲染的非交互序列，`FMV` 通常指提前渲染为 MP4、WMV 或其他格式电影文件的序列，运行时由引擎的全屏电影播放器回放
- `Quick time event / QTE` 快速时间事件，半交互序列，是非交互序列的一个变体。玩家必须在非交互序列中的正确时刻点击按钮才能看到成功动画并继续；否则会播放失败动画，玩家必须再次尝试，结果可能会丢失一条命或遭受其他后果

### The Local Timeline

- 可以认为动画片段有一个局部时间线，通常用变量 $t$ 表示，在片段的开头 $t=0$，在片段的结尾 $t=T$，$T$ 为片段的持续时间，$t$ 的每个唯一值称为一个时间索引（`time index`）
- `Pose Interpolation and Continuous Time` 帧的显示速率和姿势的创建速率不一定是一样的。动画师只在动画片段的特定时间点生成重要的姿势，称为关键姿势（`key poses`）或关键帧（`key frames`），然后电脑通过线性或基于曲线的插值计算其间的姿势。
  - 动画片段的时间线是连续的、可缩放的。时间 $t$ 是一个实数而不是整数，我们可以在片段的任意时间点采样；时间缩放可以通过更稠密或更稀疏的采样让人物移动得更慢或更快，一个负时间缩放甚至可以用于反向播放动画
- `Time Units` 最好用秒作为单位，也可以用帧作为单位，前提是预先定义了帧的持续时间。原则是保证帧间“渐变”或缩放动画播放速度时足够的分辨率
- `Frame versus Sample` 术语帧在游戏行业通常由多个含义，有时表示一个时间段，一秒有 30 或 60 帧，有时表示一个时间点，例如“第 42 帧的人物姿势”这种说法
  - 可以使用采样（`sample`）来指代时间点，帧只用于指代时间段，这样如果动画以每秒 30 帧的速率创建时，则每秒包含 31 个采样
- `Frames, Samples and Looping Clips` 当一个动画片段是不循环的，则 $N$ 帧动画包含 $N+1$ 个不同采样；当一个动画片段是循环的，则最后一个采样是冗余的，所以 $N$ 帧动画包含 $N$ 个不同采样
- `Normalized Time (Phase)` 有时使用标准化时间单位 $u$ 十分方便，这样动画开头 $u=0$，结尾 $u=1$，不用考虑动画持续时间 $T$。有时将标准化时间称为动画片段的相位（`phase`），类似正弦波的相位

### The Global Timeline

- 游戏角色有一个全局时间线，开始于角色第一次产生的时间点或关卡及游戏的开始时间点。播放一个动画可以认为是动画片段局部时间线到角色全局时间线的简单映射。
- 动画片段映射到全局时间线所需的信息
  - 全局时间线开始时间 $\tau_{start}$
  - 动画片段回放速率 $R$
  - 动画片段持续时间 $T$
  - 动画片段循环次数 $N$
- 全局时间 $\tau$ 和局部时间 $t$ 的转换为
  
  $$
  t=(\tau-\tau_{start})R
  $$
  $$
  \tau=\tau_{start}+\frac{1}{R}t
  $$

- 动画片段不循环即$N=1$ 时
  
  $$
  t=clamp[(\tau-\tau_{start})R]|_0^T
  $$

- 动画片段无限循环即 $N=\infty$ 时
  
  $$
  t=((\tau-\tau_{start})R)\ mod\ T
  $$

- 动画片段循环有限次即 $1<N<\infty$ 时
  
  $$
  t=(clamp[(\tau-\tau_{start})R]|_0^{NT})\ mod\ T
  $$

- 大多数游戏引擎直接使用局部时间线而不使用全局时间线，但是直接使用全局时间可以带来一些非常有用的好处，例如同步动画

### Comparison of Local and Global Clocks

- 动画系统必须跟踪当前播放的每个动画的时间索引，有以下两个选择，它们有各自的优点，局部时钟是设计动画系统时最明显的选择
  - 局部时钟，动画片段开始播放时时间索引为零，为了及时推进动画，我们逐个推进每个动画片段的局部时钟。如果片段具有非单位播放速率 $R$，其局部时钟前进的量必须由 $R$ 缩放
  - 全局时钟，角色有一个全局时钟，每个片段简单记录其开始播放的全局时间 $\tau_{start}$，然后局部时钟可以由全局时间计算得到
- `Synchronizing Animations with a Local Clock` 使用局部时钟时，同步两个或多个动画片段，只需要它们在游戏的同一瞬间开始播放就可以简单实现。但是如果播放命令来自于引擎的不同子系统，同步可能会出现问题
- `Synchronizing Animations with a Global Clock` 全局时钟方法可以解决同步问题，因为根据定义，时间线起点 $\tau=0$ 在所有片段中都是通用的。如果多个动画的全局开始时间一致，它们会完美同步开始；如果它们的回放速率一致，它们将保持同步，没有漂移。考虑到角色时钟间的差异，我们可以调整全局开始时间，也可以简单使所有角色共享一个主时钟

### A Simple Animation Data Format

- 通常，动画数据从一个 Maya 场景文件提取出，通过以每秒 30 或 60 采样的速率对骨架姿势进行离散采样。一个采样包括骨架中每个关节的完整姿势，这些姿势保存为 SQT 格式：对每个关节 $j$，缩放分量为单个浮点标量 $S_j$ 或三元向量 $S_j=\begin{bmatrix} S_{jx} & S_{jy} & S_{jz} \end{bmatrix}$，旋转分量为四元组 $Q_j=\begin{bmatrix} Q_{jx} & Q_{jy} & Q_{jz} & Q_{jw} \end{bmatrix}$，平移分量为三元向量 $T_j=\begin{bmatrix} T_{jx} & T_{jy} & T_{jz} \end{bmatrix}$。我们有时说动画每个关节最多包含 10 个通道，就是指 $S_j$、$Q_j$、$T_j$ 的这 10 个分量
- `Animation Retargeting` 动画重定向，重定向为一个骨骼制作的动画，以便他们可以在不同的骨架上工作。一个动画通常只与一个骨架兼容，但是多个密切相关的骨架是个例外，例如一组相同的骨架，只有一些可选的不影响基础层次结构的叶子关节不一样，则为一个骨架制作的动画可以在其他任意一个骨架上工作，只需要引擎能够忽略在骨架中找不到的关节的动画通道

### Continuous Channel Functions

- 一个动画片段的采样实际上只是关于时间的连续函数的定义，可以认为是 10 个标量值函数或两个向量值函数和一个四元组值函数。
- 理论上这些通道函数（`channel function`）平滑且连续（除非明确制作成不连续的，例如相机切割）；然而实际上，许多游戏引擎在采样之间线性插值，这种情况下实际使用的函数是潜在连续函数的分段线性近似（`piecewise linear approximations`）

### Metachannels

- 许多游戏允许为动画定义额外的“元通道”数据。这些通道可以编码游戏定义的信息，这些信息不必与骨架姿势直接相关，但是需要与动画同步
- 通常可以定义一个特殊通道，包含在各种时间索引处的事件触发器（`event triggers`），每当动画的局部时间索引通过其中一个触发器时，就会向游戏引擎发送一个事件，然后引擎以合适的方式响应。一个常见的用途是表示动画过程中哪个点应该播放哪个声音或粒子效果
- `Locators` 定位器，Maya 中的叫法，一种特殊的关节，允许与骨架本身的关节一起动画，可以用于编码游戏中几乎任何物体的位置和方向
- 定位器的一个典型应用是定义游戏镜头在动画过程中如何定位和定向。在 Maya 中将定位器约束到镜头，镜头的定位器导出，在游戏中被用于动画过程中移动游戏镜头。镜头的视野（焦距）、其他镜头属性也可以动画化，只需要将相关数据放入一个或多个浮点通道中
- 其他非关节动画通道包括
  - 纹理坐标滚动
  - 纹理动画（纹理坐标滚动的特殊情况，滚动范围为纹理内线性排列的帧）
  - 动画材质参数（颜色、镜面反射率、透明度等）
  - 动画照明参数（半径、锥角、强度、颜色等）
  - 其他随时间变化且以某种方式与动画同步的参数

## Skinning and Matrix Palette Generation

- `Skinning` 蒙皮，将 3D 网格的顶点附着到一个摆姿势的骨架的过程